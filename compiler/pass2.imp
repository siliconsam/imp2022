!   Intel 80386 IMP77 compiler second pass
!
! Copyright 2021 JD McMullin for various enhancements
! Copyright 2002 NB Information Limited.
!        from an original version probably -
! Copyright The University of Edinburgh
!        and various contributions 
! Copyright many other individuals,
!        but most particularly
! Copyright 1977-1980 Peter Robertson

! Version 2.03 - Oct 25th 2022
!   * Implemented code to use %short %integer for the normal
!     arithmetic, logical operations.
!     Required implementing the MOVSX instruction
!
! Version 2.02 - October 2022
!   * Implemented the PLANT iCode
!     so *=constant can be a part of IMP77 source
!     Constant must fit into a byte (0..255)
!   * Fixed error when returning a %result for a %byte %function
!     Compiler erroneously had %EAX representing an address rather
!     than a value. Corresponding fix needed for %short %function
!     and %integer %function results.
!     N.B. %EAX contains a value NOT an address to the value for
!          those %function results that can fit into 32-bits
!   * Inside IMP77 source embedded machine code uses %EAX - %BH
!     notation to represent a register.
!
! Version 2.01 - August 2022
!   * Added routines to output different sized data to the code buffer
!   * Modified ibj write routines so they could become an external module
!    (this external module could then include the ibj read routines)
!
! Version 2.00 - February 2021
!   * Enabled machine code to be embedded (NO floating point implemented)
!
! Version 1.03 - October 2003
!   * Properly cleaned up GP TAG list at end of a block
!   * Tidied up some constant tables with names
!     (a hangover from the SKIMP version)
!   * Corrected ISWORK to only be true for full-size string work blocks

%begin

    !SIZE CONSTANTS
    %constinteger  max vars  = 1024
    %constinteger  max stack = 16
    %constinteger  max labs  = 500
    %constinteger  max level = 16
    %constinteger  Max GP    = 1200 { JDM JDM Increased from 120 }

    ! SOME WEE ENVIRONMENTAL THINGS
    ! Main program internal name
    %conststring(12) program ip = "Main Program"

    ! Main program external name
    %conststring(8)  program ep = "__impmain"

    ! prefixed to %system routine idents
    %conststring(5)  system prefix = "_imp_"

    ! I/O file handles
    ! input streams
    %constinteger icode   = 1
    %constinteger source  = 2
    ! output streams
    %constinteger report  = 0
    %constinteger objout  = 1
    %constinteger listout = 2

    ! DIAGNOSE BITS
    ! JDM JDM Identify which IMP pass this is
    %constinteger  passId = 2

    ! CONTROL BITS
    ! The only active check is check array
    %constinteger  check capacity = 1
    %constinteger  check unass    = 2
    %constinteger  check array    = 4
    %constinteger  check bits     = check array

    ! REGISTERS - basic register number = actual value + 1
    ! 32-bit registers
    %constinteger   EAX = 1
    %constinteger   ECX = 2
    %constinteger   EDX = 3
    %constinteger   EBX = 4
    %constinteger   ESP = 5
    %constinteger   EBP = 6
    %constinteger   ESI = 7
    %constinteger   EDI = 8

    ! Floating point coprocessor stack registers
    %constinteger   FR0 = 9
    %constinteger   FR1 = 10
    %constinteger   FR2 = 11
    %constinteger   FR3 = 12
    %constinteger   FR4 = 13
    %constinteger   FR5 = 14
    %constinteger   FR6 = 15
    %constinteger   FR7 = 16

    ! 8 bit registers - actual value + 17
    %constinteger   AL  = 17
    %constinteger   CL  = 18
    %constinteger   DL  = 19
    %constinteger   BL  = 20
    %constinteger   AH  = 21
    %constinteger   CH  = 22
    %constinteger   DH  = 23
    %constinteger   BH  = 24

    ! 16-bit registers
    %constinteger   AX  = 25
    %constinteger   CX  = 26
    %constinteger   DX  = 27
    %constinteger   BX  = 28
    %constinteger   SP  = 29
    %constinteger   BP  = 30
    %constinteger   SI  = 31
    %constinteger   DI  = 32

    ! Pseudo Registers
    %constinteger  any   = 33 { Truly any register }
    %constinteger  anyg  = 34 { A "General Purpose" byte accessible register }
                              { (EAX, EBX, ECX, EDX) }
    %constinteger  anyp  = 35 { A pointing register (EBX, ESI, EDI) }
    %constinteger  anyf  = 36 { Generally means the top of the floating point stack }

    ! DATA FORMS

    ! EXTERNAL FORM
    %constinteger  simple         = 1
    %constinteger  name           = 2
    %constinteger  label          = 3
    %constinteger  recordformat   = 4
    %constinteger  switch         = 6
!    %constinteger  routine        = 7
!    %constinteger  function       = 8
!    %constinteger  map            = 9
!    %constinteger  predicate      = 10
    %constinteger  array          = 11
    %constinteger  arrayname      = 12
    %constinteger  namearray      = 13
    %constinteger  namearrayname  = 14

    ! INTERNAL
    %constinteger  constant    = 0
    %constinteger  v in r      = 1
    %constinteger  av in r     = 2
    %constinteger  a in r      = 3
    %constinteger  v in s      = 4
    %constinteger  av in s     = 5
    %constinteger  a in s      = 6
    %constinteger  v in rec    = 7
    %constinteger  av in rec   = 8
    %constinteger  a in rec    = 9
    %constinteger  pgm label   = 10

    ! DATA TYPES
    %constinteger  general  = 0
    %constinteger  integer  = 1
    %constinteger  real     = 2
    %constinteger  string   = 3
    %constinteger  record   = 4
    ! Private internal derived types
    %constinteger  byte     = 5
    %constinteger  short    = 6
    %constinteger  long     = 7
    %constinteger  lreal    = 8
    ! JDM JDM additional datatypes added for use by typeof/sizeof functions
    ! They correspond to some of the external forms
    %constinteger  tarray   = 9
    %constinteger  tlabel   = 10
    %constinteger  xarray          = 11
    %constinteger  xarrayname      = 12
    %constinteger  xnamearray      = 13
    %constinteger  xnamearrayname  = 14

    ! JDM JDM vsize and gen map arrays extended to cope with extra
    ! type parameters passed to typeof/sizeof internal macro/functions
    !   typeof mapped values
    !   (originally taken from "The Imp77 Language - A Reference Manual)
    !   more mapped values could be added as needed
    !
    ! code v  name (returned by typeName)
    !    0 = "unknown"
    !    1 = "integer"
    !    2 = "real"
    !    3 = "string"
    !    4 = "record"
    !    5 = "byteinteger"
    !    6 = "shortinteger"
    !    7 = "longinteger"
    !    8 = "longreal"
    !    9 = "array"
    !   10 = "label"
    !    * = "unknown"

    ! size of each of those internal types in bytes
    %constbyteintegerarray  vsize(general:xnamearrayname) =
        0,4,4,0,0,1,2,4,8,0,0,0,0,0,0

    ! Define type codes known externally (to pass 3 and user):
    ! The extended list of type codes are NOT specified here
    %constbyteintegerarray  gen map(general:xnamearrayname) =
        0,1,2,3,4,5,6,7,8,9,10,9,9,9,9

    ! GENERIC STORE ALIGNMENT - ASSUME 80386
    %constinteger  align     = 3
    %constinteger  word size = 4 { in bytes }

    !OWN INFO
    %constinteger  own      = 1
    %constinteger  con      = 2
    %constinteger  external = 3
    %constinteger  system   = 4
    %constinteger  dynamic  = 5
    %constinteger  primrt   = 6
    %constinteger  permrt   = 7

{Procedure end codes}

    %constinteger   Map     = -2,
                    Fn      = -1, { negative value implies stacked result }
                    Routine =  0,
                    True    =  1,
                    False   =  2

    ! PERM ROUTINE INDEXES
    %constinteger  iexp   =  1 { Integer Exponent                    }
    %constinteger  fexp   =  2 { floating exponent                   }
    %constinteger  smove  =  3 { string copy (length checked)        }
    %constinteger  sjam   =  4 { string copy (whatever fits)         }
    %constinteger  sconc  =  5 { string concatenate (length checked) }
    %constinteger  sjconc =  6 { concatenate whatever fits           }
    %constinteger  sresln =  7 { string resolution                   }
    %constinteger  scomp  =  8 { string compare                      }
    %constinteger  aref   =  9 { array access                        }
    %constinteger  adef   = 10 { array definition                    }
    %constinteger  signal = 11 { %signal                             }
    %constinteger  stop   = 12 { %stop                               }
    %constinteger  lastperm = stop
    %integer       lasthidden = lastperm

    ! and the corresponding linkage names for the perms
    %const %string(12)%array permname(1:lastperm)=
    "_IMPIEXP",
    "_IMPFEXP",
    "_IMPSTRCPY",
    "_IMPSTRJAM",
    "_IMPSTRCAT",
    "_IMPSTRJCAT",
    "_IMPSTRRES",
    "_IMPSTRCMP",
    "_IMPAREF",
    "_IMPADEF",
    "_IMPSIGNAL",
    "_IMPSTOP"

    ! and the corresponding linkage names for the hidden routines
    ! These take 1 parameter and return a value in %EAX
    ! The order of hidden names is critical
    ! The hidden linkage names follow on from the perm names
    %const %string(31)%array hidden name(1:3)=
    "_IMPCHECK1",
    "_IMPCHECK2",
    "_IMPCHECK3"

    ! Special hidden routines only inserted by the pass2 of the compiler
    ! when the %control directive forces (control&4 # 0) - i.e. bit 2 set
    ! These routines can trigger an %event X,Y,Z as a side-effect
    ! should the corresponding test fail.
    ! They all return a possibly amended value of the integer parameter
    ! in %EAX register
    !
    ! "impcheck1" checks if x in range -32768..32767
    !   - failure returns %EAX = 0 and triggers %event 1,6,x
    !   - success returns %EAX = x
    ! %external %routine             %spec    impcheck1( %integer x)
    !
    ! "impcheck2" checks if x in range -32768..32767 AND (x # 0)
    !   - failure returns %EAX = 0 and triggers %event 1,6,x
    !   - success returns %EAX = x
    ! %external %routine             %spec    impcheck2( %integer x)
    !
    ! "impcheck3" checks if (x # 0)
    !   - failure returns %EAX = 1 and triggers %event 1,4
    !   - success returns %EAX = x
    ! %external %routine             %spec    impcheck3( %integer x)

    %integer check1 { routine tag for "_IMPCHECK1" }
    %integer check2 { routine tag for "_IMPCHECK2" }
    %integer check3 { routine tag for "_IMPCHECK3" }

    ! Compiler Internal Operations (not to be confused with OpCodes)
    %constinteger  ADDx    = 1
    %constinteger  SUBx    = 2
    %constinteger  MULx    = 3
    %constinteger  DIVx    = 4
    %constinteger  CONCx   = 5
    %constinteger  ANDx    = 6
    %constinteger  ORx     = 7
    %constinteger  XORx    = 8
    %constinteger  LSHx    = 9
    %constinteger  RSHx    = 10
    %constinteger  REMx    = 11
    %constinteger  EXPx    = 12
    %constinteger  REXPx   = 13
    %constinteger  RDIVx   = 14
    %constinteger  NOTx    = 15
    %constinteger  NEGx    = 16
    %constinteger  ABSx    = 17
    %constinteger  unaries = 15

    ! opcode indexes...

    ! simple (no operand) ones first
    %constinteger NOP   = 0
    %constinteger CWD   = 1
    %constinteger RET   = 2
    %constinteger SAHF  = 3
    %constinteger LAHF  = 4
    %constinteger LEAVE = 5

    ! simple unary math functions
    %constinteger DEC = 6
    %constinteger INC = 7
    %constinteger NEG = 8
    %constinteger NOT = 9

    ! simple unary moves
    %constinteger POP  = 10
    %constinteger PUSH = 11

    ! two operand moves
    %constinteger LEA  = 12
    %constinteger MOV  = 13
    %constinteger XCHG = 14
    %constinteger MOVSX = 15

    ! simple two operand math functions
    %constinteger ADC = 16
    %constinteger ADD = 17
    %constinteger AND = 18
    %constinteger CMP = 19
    %constinteger OR  = 20
    %constinteger SUB = 21
    %constinteger XOR = 22
    ! slightly more complicated two operand math
    %constinteger SHL  = 23
    %constinteger SHR  = 24
    %constinteger IDIV = 25
    %constinteger IMUL = 26

    ! calls and jumps
    %constinteger CALL = 27
    %constinteger JE   = 28
    %constinteger JNE  = 29
    %constinteger JG   = 30
    %constinteger JGE  = 31
    %constinteger JL   = 32
    %constinteger JLE  = 33
    %constinteger JA   = 34
    %constinteger JAE  = 35
    %constinteger JB   = 36
    %constinteger JBE  = 37
    %constinteger JMP  = 38

    ! Floating point instructions - note that these map directly onto
    ! 8087 sequences, unlike the generic MOV, ADD style of the base
    ! operations for the 8086
    %constinteger   FILD    = 39
    %constinteger   FLDD    = 40
    %constinteger   FLDQ    = 41
    %constinteger   FSTI    = 42
    %constinteger   FSTD    = 43
    %constinteger   FSTQ    = 44
    %constinteger   FADD    = 45
    %constinteger   FSUB    = 46
    %constinteger   FSUBR   = 47
    %constinteger   FMUL    = 48
    %constinteger   FDIV    = 49
    %constinteger   FDIVR   = 50
    %constinteger   FCMP    = 51
    %constinteger   FCHS    = 52
    %constinteger   FABS    = 53
    ! Special floating point things
    %constinteger   FSTSW   = 54
    %constinteger   FLDZ    = 55
    %constinteger   FLDPI   = 56

    ! modifiers to memory base for accessing global memory
    %constinteger   DATA    = 16_10
    %constinteger   COT     = 16_20
    %constinteger   BSS     = 16_30
    %constinteger   DISPLAY = 16_40
    %constinteger   EXT     = 16_50
    %constinteger   SWT     = 16_60
    %constinteger   CODE    = 16_70

    ! opcodes
    %const %string(5) %array opname(NOP:JMP) =
      "NOP",   "CWD",   "RET",  "SAHF",  "LAHF", "LEAVE",
      "DEC",   "INC",   "NEG",   "NOT",
      "POP",  "PUSH",
      "LEA",   "MOV",  "XCHG", "MOVSX",
      "ADC",   "ADD",   "AND",   "CMP",    "OR",   "SUB",   "XOR",
      "SHL",   "SHR",  "IDIV",  "IMUL",
     "CALL",    "JE",   "JNE",
       "JG",   "JGE",    "JL",   "JLE",
       "JA",   "JAE",    "JB",   "JBE",   "JMP"

    ! This list reverse maps opId to internal opX
    %constant %integer %array opGenericId(NOP:JMP) =
    {   NOP,   CWD,   RET,  SAHF, LAHF, LEAVE, }
         -1,    -1,    -1,    -1,   -1,    -1,
    {   DEC,   INC,   NEG,   NOT, }
         -1,    -1,  NEGx,  NOTx,
    {   POP,  PUSH, }
        POP,  PUSH,
    {   LEA,   MOV,  XCHG, MOVSX, }
         -1,   MOV,    -1, MOVSX,
    {   ADC,   ADD,   AND,   CMP,    OR,   SUB,   XOR, }
         -1,  ADDx,  ANDx,   CMP,   ORx,  SUBx,  XORx,
    {   SHL,   SHR,  IDIV,  IMUL, }
       LSHx,  RSHx,  DIVx,  MULx,
    {  CALL,    JE,   JNE, }
         -1,    -1,    -1,
    {    JG,   JGE,    JL,   JLE, }
         JG,    -1,    -1,    -1,
    {    JA,   JAE,    JB,   JBE,   JMP }
         -1,    -1,    -1,    -1,   JMP

    %const %byte %integer %array opvalue(NOP:JMP) =
    16_90, 16_99, 16_C3, 16_9E, 16_9F, 16_C9,
    16_FF, 16_FF, 16_F7, 16_F7,
    16_8F, 16_FF,
    16_8B, 16_89, 16_87, 16_BF,     { LEA is fudged as if it were m <- r, to allow the flip }
    16_11, 16_01, 16_21, 16_39, 16_09, 16_29, 16_31,
    16_D1, 16_D1, 16_F7, 16_F7,
    16_E8, 16_74, 16_75,
    16_7F, 16_7D, 16_7C, 16_7E,
    16_77, 16_73, 16_72, 16_76, 16_EB

    ! 8 bit equivalent opcodes
    ! Some are not actually 8 bit, but are added for completenes }
    %const %byte %integer %array op8value(NOP:JMP) =
    16_90, 16_99, 16_C3, 16_9E, 16_9F, 16_C9, { included for completeness }
    16_FE, 16_FE, 16_F6, 16_F6,
    16_8F, 16_FF,                           { included for completeness }
    16_8B, 16_88, 16_86, 16_BE,             { LEA is not applicable for 8 bit }
    16_10, 16_00, 16_20, 16_38, 16_08, 16_28, 16_30,
    16_D0, 16_D0, 16_F6, 16_F6,
    16_E8, 16_74, 16_75,
    16_7F, 16_7D, 16_7C, 16_7E,
    16_77, 16_73, 16_72, 16_76, 16_EB  { included for completeness }

    %const %byte %integer %array aximmediatevalue(NOP:XOR) =
    0, 0, 0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0,
    0, 16_B8, 0,  0,
    16_15, 16_05, 16_25, 16_3D, 16_0D, 16_2D, 16_35

    {Condition codes}

    { The "Never" test should never! be used. The others are all used } 
    %constinteger   Never  = 0,
                    EQ     = 1,
                    LT     = 2,
                    LE     = 3,
                    GT     = 4,
                    GE     = 5,
                    NE     = 6,
                    Always = 7,
                    TT     = 8,
                    FF     = 9
    %constbytearray Reverse(Never:FF) = Never  {Never},
                                        EQ     {EQ},
                                        GT     {LT},
                                        GE     {LE},
                                        LT     {GT},
                                        LE     {GE},
                                        NE     {NE},
                                        Always {Always},
                                        TT     {TT},
                                        FF     {FF}
    %constbytearray Negated(Never:FF) = Always {Never},
                                        NE     {EQ},
                                        GE     {LT},
                                        GT     {LE},
                                        LE     {GT},
                                        LT     {GE},
                                        EQ     {NE},
                                        Never  {Always},
                                        FF     {TT},
                                        TT     {FF}

    {Never - This is added for completeness}
    %constbytearray TestToOp(Never:FF) =    JMP {Never},
                                            JE  {EQ},
                                            JL  {LT},
                                            JLE {LE},
                                            JG  {GT},
                                            JGE {GE},
                                            JNE {NE},
                                            JMP {Always},
                                            JNE {TT},
                                            JE  {FF}

    {Never - This is added for completeness}
    %constbytearray TestToUnsignedOp(Never:FF) =    JMP {Never},
                                                    JE  {EQ},
                                                    JB  {LT},
                                                    JBE {LE},
                                                    JA  {GT},
                                                    JAE {GE},
                                                    JNE {NE},
                                                    JMP {Always},
                                                    JNE {TT},
                                                    JE  {FF}

    ! JDM JDM debug count of iCode instructions
    %integer icodeCount = 0

    ! Code symbol
    %integer iCodeInst

    ! Standard IMPish data structures
    ! Variables are declared here
    %recordformat  varfm( %byteinteger level,
                          %byteinteger type, form, scope, dim,
                          %integer disp, extdisp, 
                                   format, size, pbase, extra )
    %record(varfm)%array  var(0:max vars)
    %record(varfm)%name   decvar
    %record(varfm)        begin

    ! The compiler is stack based
    ! JDM JDM changed record format to reference the IMP variable name
    ! via var(var no)_idname
    ! This saves some memory by not adding 256 bytes per stack entry
    %recordformat  stackfm( %string(255) idname,
                            %integer var no,
                            %byteinteger aform, base,
                            %byteinteger type, form, scope, dim,
                            %integer disp, extdisp,
                                     format, size, pbase, extra )
    %record(stackfm)%array  stack(1:max stack)
    %record(stackfm)        null
    %record(stackfm)%name   top

    ! Pass 1 uses a lame label redefinition that forces us to map
    ! label ID's into unique labels for pass 3, using this database
    %recordformat LabelFm(%integer id, tag)
    %record(LabelFm)%array Labels(1:Max Labs)

    ! most recent Jump tag translation
    ! - needed when planting event blocks
    %integer J Tag

    ! Status of registers
    %ownintegerarray  activity(0:fr7) = 0,
                                        0, 0, 0, 0, -1, -1, 0, 0,
                                        0, 0, 0, 0,  0,  0, 0, 0
    %owninteger  claimed = 0

    ! Pointer registers may be pointing to non-local display
    ! - we remember them for future use
    %ownintegerarray displayhint(EAX:EDI) = 0, 0, 0, 0, 0, 0, 0, 0

    ! Math Co-processor uses a stack
    ! - we remember where it should be with this pointer
    %owninteger fpustack = 0

    ! A general purpose workspace resource
    %recordformat gp tag(%integer info, addr, flags, link)
    %record(gptag)%array gptags(0:Max GP)
    %integer gp asl;

    ! Current compiler flags (set by %control statement)
    %owninteger control = check bits

    ! Current diagnostic flags (set by %diagnose statement)
    %owninteger diagnose = 0

    ! Special directive flags for languages (other than standard imp)
    %owninteger Language Flags = 0

    ! notional code address (not real - pass3 shuffles stuff)
    %owninteger nextcad = 0

    ! current contextual level
    %owninteger level = 0

    ! vector lower/upper bound
    %integer    vlb,vub

    ! source line number
    %owninteger current line = 0

    ! stack pointer
    %owninteger stp = 0

    ! current data item size
    %integer    data size

    ! current array entry type
    %integer    array entry type

    ! local stack frame extent
    %owninteger frame = 0

    ! start of parameter stack
    %integer    parms

    ! condition inversion flag
    %owninteger invert = 0

    ! condition was non-standard (generally FPU compare)
    %owninteger compare unsign = 0

    ! address of code hole
    %owninteger uncond jump = 0

    ! -1 = RECORDS, 1 = PROCEDURE, 2 = SPEC
    %owninteger block type = 1

    ! if # 0, indicates we are inside a parameter list
    %owninteger in params = 0

    ! Information about OWNs currently being declared
    %integer    otype,
                owntype,
                ownform

    ! More about current declaration
    %integer    spec,
                potype

    ! Place to store Real and LReal function results
    %owninteger Fp Result Loc = -1

    ! Size in WORDS of switch segment table
    %constinteger max switch = 1000
    %integerarray swtab(0:max switch)
    ! pointer to next switch segment entry
    %owninteger swtp = 0

    %ownstring(255) external id = "",
                    alias       = "",
                    block name  = ""

    ! current string literal
    %byteintegerarray  current string(0:255)

    ! WORK List - used to optimise use of temporary storage
    ! There is a head of list for each contextual level
    %ownintegerarray worklist(1:max level) = 
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

    ! floating point value for constants and initialisers
    %longreal rvalue

    ! value to use when initialising OWNs
    %owninteger ownval = 0

    !-----------------------------------------------------------
    ! start of "enumeration to String/name functions
    ! The following are debug functions to convert "enumerated" values
    ! to an appropriate String/name
    !-----------------------------------------------------------

    ! definitions of iCode values used by pass1 and pass2
    %include "icd.types.inc"

    ! various icode utility functions
    %include "icd.utils.inc"

    %routine ListICode
        selectoutput(listout)
        printstring( "icode(" )
        printstring( itos(iCodeCount,5) )
        printstring( "): " )
        printstring( getiCodeName(iCodeInst) )
    %end

    %routine ListICodeLine
        ListICode
        newline
    %end

    !-----------------------------------------------------------
    ! end of "enumeration to String/name functions
    !-----------------------------------------------------------

    ! Moved declarations so they can be used by debug routines
    %const %string(4) %array reg32name(EAX:EDI) =
    "%EAX", "%ECX", "%EDX", "%EBX", "%ESP", "%EBP", "%ESI", "%EDI"

    %const %string(4) %array reg16name(AX:DI) =
    "%AX", "%CX", "%DX", "%BX", "%SP", "%BP", "%SI", "%DI"

    %const %string(4) %array reg8name(AL:BH) =
    "%AL", "%CL", "%DL", "%BL", "%AH", "%CH", "%DH", "%BH"

    %const %string(4) %array regfloatname(FR0:FR7) =
    "%FR0", "%FR1", "%FR2", "%FR3", "%FR4", "%FR5", "%FR6", "%FR7"

    %const %string(7) %array relocname(0:6) =
    "", "DATA", "COT", "BSS", "DISPLAY", "EXTERN", "SWTAB"

    %string(4) %function reg as name( %integer n )
        %string(4) t

        t = ""
        ! For a i386 is this a 32-bit register
        %if (length(t) = 0) %and (EAX <= n <= EDI) %start
            ! This is a 32-bit register
            t = reg32name(n)
        %finish

        ! For a i386 is this a 16-bit register
        %if (length(t) = 0) %and (AX <= n <= DI) %start
            ! This is a 16-bit register
            t = reg16name(n)
        %finish

        ! For a i386 is this an 8-bit register
        %if (length(t) = 0) %and (AL <= n <= BH) %start
            ! This is an 8-bit register
            t = reg8name(n)
        %finish

        ! For a i386 is this a floating point register
        %if (length(t) = 0) %and (FR0 <= n <= FR7) %start
            ! This is a floating point register
            t = regfloatname(n)
        %finish

        %if (length(t) = 0) %start
            ! Drat we don't know which register this is
            t = "???"
        %finish

        %result = t
    %end

    !-----------------------------------------------------------
    ! Start with machine independent utility functions and stack
    ! manipulation and debug
    !-----------------------------------------------------------

    %string(255) %function hexint( %integer nn, places )
        %constinteger base = 16

        %own %string(16) basechar = "0123456789ABCDEF"
        %string(31) reversed,human
        %integer n,i

        length(reversed) = 0

        n = nn
        %while (n # 0) %cycle
            length(reversed) = length(reversed) + 1
            charno(reversed,length(reversed)) = charno(basechar,1+(n&15))
            n = n >> 4
        %repeat

        ! Pad out the digits with zero's if places more than actual number of 'digits'
        %if (places > length(reversed)) %start
            %while length(reversed) < places %cycle
                length(reversed) = length(reversed) + 1
                charno(reversed,length(reversed)) = '0'
            %repeat
        %finish

        ! Now reverse the digits for human readability.
        length(human) = 0
        %for i = length(reversed), -1, 1 %cycle
            length(human) = length(human) + 1
            charno(human,length(human)) = charno( reversed, i )
        %repeat

        %result = human
    %end

    ! Routines to write the intermediate file
    ! Record format is:
    ! <type><length><data>
    ! For debug purposes, the elements are all written as ascii
    ! characters, where <type> is a single letter, <length> is a single
    ! hex digit, length refers to the number of bytes (2 chars) of data.

    ! define the IBJ record types
    %include "ibj.types.inc"

    ! include the IMP code to:
    ! 1) remember the IBJ output stream
    ! 2) routine to output a number X to P hex digits
    ! 3) routine to write the IBJ buffer
    ! 4) routines to store byte,tag,word,long,string data in the IBJ buffer
    %include "ibj.utils.inc"

    !                                                  >> SHOW <<
    %routine  show(%record(stackfm)%name v)
        %string(255) s
        ! JDM JDM The field widths have been tweaked to align columns
        spaces(1); printstring(itos(v_varno,5))
        printstring(" :" )
        s = get type name(v_type)
        spaces(1); spaces(13 - length(s)); printstring(s)

        s = get internal form name(v_form)
        spaces(1); spaces(10 - length(s)); printstring(s)

        s = reg as name(v_base)
        spaces(1); spaces(4 - length(s)); printstring(s)

        spaces(1); printstring(itos(v_disp,6))
        spaces(1); printstring(itos(v_extdisp,6))
        spaces(1); printstring(itos(v_size,3))
        spaces(1); printstring(itos(v_extra,3))
        spaces(1); printstring(itos(v_format,3))
        spaces(1); printstring(itos(v_dim,3))
        spaces(1); printstring(itos(v_pbase,3))
        ! JDM JDM retrieve the original variable name
        ! Beware case when (v_varno = 0) and (v_form = constant)
        spaces(1); print string("'")        
        print string(get symbol name(v_varno)) %unless (v_varno = 0) %and (v_form = 0)
        print string("'")
        newline
    %end

    %routine dump tag var( %integer tag, %string(7) prefix )
        %record(varfm)%name v

        v == var(tag)

        spaces(1); print string("VAR entry ".prefix); newline
        spaces(5); print string("tag=".itos(tag,0)); newline
        spaces(5); print string("name=".get symbol name(tag)); newline
        spaces(5); print string("type=".get type name(v_type)); newline
        spaces(5); print string("form=".get internal form name(v_form)); newline
        spaces(5); print string("level=".itos(v_level,0)); newline
        spaces(5); print string("scope=".itos(v_scope,0) ); newline
        spaces(5); print string("reloc=".relocname(v_scope>>4) ); newline
        spaces(5); print string("dim=".itos(v_dim,0)); newline
        spaces(5); print string("disp=".hexint(v_disp,8)." ".itos(v_disp,0) ); newline
        spaces(5); print string("extdisp=".itos(v_extdisp,0)); newline
        spaces(5); print string("format=".itos(v_format,0)); newline
        spaces(5); print string("size=".itos(v_size,0)); newline
        spaces(5); print string("pbase=".itos(v_pbase,0)); newline
        spaces(5); print string("extra=".itos(v_extra,0)); newline

    %end

    ! Simple ABORT routine
    %routine abort(%string(255) message)
        %integer j

        select output(report)
        printstring("Pass 2 abandoned at line ");
        write(current line, 0);
        printstring(" : ");
        printstring(message)
        newline
        %if (stp # 0) %start
            print string("STACK:");  newline
            printstring("  StackId  VarNo :           Typ        Frm Bse      Dsp  ExtDsp  Siz  Xtr  Fmt  Dim  Pba Name" ); newline
            %for j = 1,1,stp %cycle
                spaces(1); printstring(itos(j,7))
                show(stack(j))
            %repeat
        %finish
        %signal 0,-1
    %end

    !                                                  >> WARN <<
    %routine  warn(%integer  n)
        %string(255) warning
        %switch  w(1:10)
        -> w(n)
w(1):   warning = "Division by zero";                   -> at
w(2):   warning = "Illegal FOR";                        -> at
w(3):   warning = "Non-local control variable?";        -> at
w(4):   warning = "Invalid parameter for READ SYMBOL";  -> at
w(5):   warning = "String constant too long";           -> at
w(6):   warning = "No. of shifts outwith 0..31";        -> at
w(7):   warning = "Illegal constant exponent";          -> at
w(8):   warning = "Byte numerical constant too big";    -> at
w(9):   warning = "Short numerical constant too big";   -> at
w(10):  warning = "Integer numerical constant too big"; -> at
at:
        select output(report)
        print string("*WARNING: line")
        write(current line, 0)
        print string(": ")
        print string( warning )
        newline
        select output(objout)
    %end

    !                                                  >> MONITOR <<
    %routine  monitor(%record(stackfm)%name  v, %string(15) text)
        select output(report)
        print string(text)
        print symbol(':')
        spaces(15-length(text))
        show(v)

        %if (diagnose&16 # 0) %start
            ! only dump monitor data into listing if we have requested iCode data
            select output(listout)
            print string(text)
            print symbol(':')
            spaces(15-length(text))
            show(v)
        %finish

        select output(objout)
    %end

    !                                                  >> GET GP TAG <<
    %integerfn get gp tag
        %integer l

        %if (gp asl = 0) %then abort("GP Tags")
        l = gp asl
        gp asl = gp tags(l)_link
        %result = l
    %end

    !                                                  >> RET GP TAG <<
    %integerfn ret gp tag(%integer index)
        %integer link

        link = gp tags(index)_link
        gp tags(index)_link = gp asl
        gp asl = index
        %result = link
    %end

    !------------------------------------------------------
    ! Machine dependent utility routines
    !------------------------------------------------------

    ! Add corresponding bytes for the listing
    !    (not always the same for fudged opcodes)
    %own %integer listptr = 0
    %const %integer lstbufmax = 11
    %own %byte %integer %array listbytes(0:lstbufmax)

    ! Routine to provide the address and hex opcode listing in the
    ! diagnostic output
    %routine listpreamble
        %integer i;

        select output(listout)
        space
        writehex(nextcad, 4)
        space
        %for i = 0, 1, 9 %cycle
            %if (i < listptr) %start
                writehex(listbytes(i), 2)
                space
            %else
                spaces(3)
            %finish
        %repeat
        spaces(8)
        nextcad = nextcad + listptr
        listptr = 0
    %end

    ! puts a normal list byte into the listing pipe
    %routine putlistbyte(%integer b)
        listbytes(listptr) = b
        listptr = listptr + 1
    %end

    ! puts a 16-bit integer (2-bytes) into the listing pipe
    %routine putlistword(%integer t)
        putlistbyte( (t >> 0)&255 )
        putlistbyte( (t >> 8)&255 )
    %end

    ! puts a 32-bit integer (4-bytes) into the listing pipe
    %routine putlistlong(%integer t)
        putlistbyte( (t >>  0)&255 )
        putlistbyte( (t >>  8)&255 )
        putlistbyte( (t >> 16)&255 )
        putlistbyte( (t >> 24)&255 )
    %end

    ! puts a normal code byte into the listing and code pipes
    ! NB. In some code-generation cases the list and code
    !     byte sequences are different.
    !     In that case we use one of the routines:
    !       - putlistbyte
    !       - putcodebyte
    !       - putcodetag
    !     instead of the putbyte routine
    %routine putbyte(%integer b)
        putlistbyte( b )
        putcodebyte( b )
    %end

    %routine putword(%integer b)
        putlistword( b )
        putcodeword( b )
    %end

    %routine putlong(%integer b)
        putlistlong( b )
        putcodelong( b )
    %end

    ! A very handy little boolean function, used for instructions
    ! with variable size immediate operands
    %predicate issmall(%integer i)
        %true %if (-128 < i < 128)
        %false
    %end

    ! And aide-memoire of intel 80386 address modes...
    !-------------------------
    !     [EAX]
    !     [ECX]
    !     [EDX]
    !     [EBX]
    !     [][]
    !     [disp32]
    !     [ESI]
    !     [EDI]
    !-------------------------
    !     [EAX+disp8]
    !     [ECX+disp8]
    !     [EDX+disp8]
    !     [EBX+disp8]
    !     [][]
    !     [EBP+disp8]
    !     [ESI+disp8]
    !     [EDI+disp8]
    !-------------------------
    !     [EAX+disp32]
    !     [ECX+disp32]
    !     [EDX+disp32]
    !     [EBX+disp32]
    !     [][]
    !     [EBP+disp32]
    !     [ESI+disp32]
    !     [EDI+disp32]
    !-------------------------

    ! mod r/m format is:
    ! mod LHREG R/M
    ! where mod = 11 for rh registers

    ! plant a modrm reference where the rh operand is a register
    ! Both parameters are actual register numbers, not internal ID's
    %routine  modrmreg(%integer reg1, %integer reg2)
        putbyte(16_C0 ! (reg1 << 3) ! (reg2))
    %end

    ! tags corresponding to linker directives...
    %const %integer %array reltag(0:6) =
    0,          { no relocation }
    IF DATA,    { dataseg offset code word }
    IF CONST,   { const seg offset code word }
    IF BSS,     { BSS relative code word }
    IF DISPLAY, { display seg offset code word }
    IF ABSEXT,  { external name absolute offset code word }
    IF SWT      { switch table offset code word }

    ! plant code for a relocated (DATA/BSS/DISPLAY/EXTERNAL) code word
    %routine relocateoffset( %integer reloc, offset, extdisp )
        %integer tag

        %if (reloc = 0) %start
            ! offset byte 0,1,2,3
            putlong(offset)
        %else
            ! so that only the offset is going into the queue
            writeifrecord(IF OBJ)

            tag = reltag(reloc)

            %if (tag = IF ABSEXT) %start
                ! JDM JDM - extdisp now placed before offset
                ! list extdisp byte 0,1
                putword(extdisp)

                ! offset byte 0,1
                ! JDM JDM - Beware the offset includes the ext disp symbol id
                putword(offset - extdisp)

                writeifrecord(IF ABSEXT)
            %else
                ! offset byte 0,1,2,3
                putlong(offset)

                writeifrecord(tag)
            %finish

        %finish

    %end

    ! plant a modrm reference where the rh operand is in memory
    ! Parameter REG1 is an actual register number,
    !    but BASE is an internal ID
    %routine  modrmmem( %integer reg1, base, disp, extdisp )
        %integer mod, reloc

        reloc = base>>4
        base = base&15

        %if (base = 0) %start
            ! no register, just a displacement
            ! mod = 000, rm = 101
            putbyte((reg1 << 3) ! 5)
            relocateoffset(reloc, disp, extdisp )
        %finish %else %start
            %if (disp = 0) %and (base # EBP) %start
                mod = 0
            %finish %else %if issmall(disp) %start
                ! fits in one byte
                mod = 1
            %finish %else %start
                mod = 2
            %finish

            ! Alas, displacement (even zero) must be output in full if
            ! the offset is relocatable
            %if (reloc # 0) %then mod = 2

!JDM JDM
!           %if (base > EDI) %or (base = ESP) %start
            %if (base > EDI) %start
                abort("Internal address mode error")
            %finish

            ! Note - base-1 maps internal ID to real register

            putbyte((mod << 6)!(reg1 << 3)!(base - 1))

            %if (mod = 1) %start
                putbyte(disp)
            %finish %else %if (mod = 2) %start
                relocateoffset(reloc, disp, extdisp )
            %finish

!JDM JDM
            %if (base = ESP) %start
                putbyte(((base -1 )<<3)!(base - 1))
            %finish
!JDM JDM
        %finish
    %end

    ! Print the corresponding memory access string
    ! BASE is an internal ID, not an actual register number
    %routine  printmemref( %integer base, disp )
        %integer reloc

        reloc = base >> 4
        base = base&15
        selectoutput(listout)
        printsymbol('[')
        %if (base # 0) %start
            printstring(reg32name(base))
            %if (reloc # 0) %start
                printsymbol('+')
                printstring(relocname(reloc))
            %finish
            %if (disp # 0) %then %start
                printsymbol('+') %if (disp > 0)
                write(disp,0)
            %finish
        %else
            %if (reloc # 0) %start
                printstring(relocname(reloc))
                printsymbol('+')
            %finish
            writehex(disp, 4)
        %finish
        printsymbol(']')
    %end

    ! An opcode with no operands (eg RET)
    %routine dumpsimple(%integer opn)

        putbyte(opvalue(opn))

        listpreamble
        printstring(opname(opn))
        newline

        writeifrecord(IF OBJ)
    %end

    ! A special bit of magic, used in record assignment
    %routine dumprepmovsb
        putbyte(16_f3) { rep }
        putbyte(16_a4) { movsb }

        listpreamble
        printstring("REP MOVSB")
        newline

        writeifrecord(IF OBJ)
    %end

    ! Used in record = 0 assignment
    %routine dumprepstosb
        putbyte(16_f3) { rep }
        putbyte(16_aa) { stosb }

        listpreamble
        printstring("REP STOSB")
        newline

        writeifrecord(IF OBJ)
    %end

    ! unary register operation - DEC, INC, NEG, NOT, POP, PUSH, IDIV, IMUL
    ! REG is an internal ID, not an actual register number
    %routine dumpur( %integer opn, reg )
        %switch ops(DEC:IMUL)

        displayhint(reg) = 0

        ->ops(opn)

ops(DEC):   putbyte(16_48 + reg - EAX);                 ->break
ops(INC):   putbyte(16_40 + reg - EAX);                 ->break
ops(NEG):   putbyte(16_F7); modrmreg(3, reg - EAX);     ->break
ops(NOT):   putbyte(16_F7); modrmreg(2, reg - EAX);     ->break
ops(POP):   putbyte(16_58 + reg - EAX);                 ->break
ops(PUSH):  putbyte(16_50 + reg - EAX);                 ->break
ops(IDIV):  putbyte(16_F7); modrmreg(7, reg - EAX);     ->break
ops(IMUL):  putbyte(16_F7); modrmreg(5, reg - EAX);     ->break
break:

        listpreamble
        printstring(opname(opn))
        space
        printstring(reg32name(reg))
        newline

        writeifrecord(IF OBJ)
    %end

    ! Plant code for a unary operation on memory
    ! BASE is an internal ID, not the actual register number
    %routine dumpum( %integer opn, base, disp, extdisp )
        %switch ops(DEC:JMP)

        ->ops(opn)

ops(DEC):   putbyte(16_FF); modrmmem(1, base, disp, extdisp);  ->break
ops(INC):   putbyte(16_FF); modrmmem(0, base, disp, extdisp);  ->break
ops(NEG):   putbyte(16_F7); modrmmem(3, base, disp, extdisp);  ->break
ops(NOT):   putbyte(16_F7); modrmmem(2, base, disp, extdisp);  ->break
ops(POP):   putbyte(16_8F); modrmmem(0, base, disp, extdisp);  ->break
ops(PUSH):  putbyte(16_FF); modrmmem(6, base, disp, extdisp);  ->break
ops(IDIV):  putbyte(16_F7); modrmmem(7, base, disp, extdisp);  ->break
ops(IMUL):  putbyte(16_F7); modrmmem(5, base, disp, extdisp);  ->break
ops(JMP):   putbyte(16_FF); modrmmem(4, base, disp, extdisp);  ->break
ops(CALL):  putbyte(16_FF); modrmmem(2, base, disp, extdisp);  ->break
break:

        listpreamble
        printstring(opname(opn))
        ! otherwise it's ambiguous for the reader
        printstring(" DWORD PTR ")
        printmemref(base, disp)
        newline

        writeifrecord(IF OBJ)
    %end

    ! Plant code for a unary operation on an 8 bit memory location
    ! Not all of the possible unary ops make sense as 8 bit destinations
    ! BASE is an internal ID, not the actual register number
    %routine dumpum8( %integer opn, base, disp, extdisp )
        %switch ops(DEC:JMP)

        ->ops(opn)

ops(DEC):   putbyte(16_FE); modrmmem(1, base, disp, extdisp);  ->break
ops(INC):   putbyte(16_FE); modrmmem(0, base, disp, extdisp);  ->break
ops(NEG):   putbyte(16_F6); modrmmem(3, base, disp, extdisp);  ->break
ops(NOT):   putbyte(16_F6); modrmmem(2, base, disp, extdisp);  ->break
ops( * ):   Abort("Invalid UM8")
break:

        listpreamble
        printstring(opname(opn))
        ! otherwise it's ambiguous for the reader
        printstring(" BYTE PTR ")
        printmemref(base, disp)
        newline

        writeifrecord(IF OBJ)
    %end

    ! Plant a Memory <- Reg operation
    ! Both BASE and REG are internal ID's, not actual register numbers
    %routine dumpmr( %integer opn, base, disp, extdisp, reg )
        %switch ops(DEC:JMP)

        ->ops(opn)

ops(SHL):   { special "shift by CL" }
            putbyte(16_D3);        modrmmem(4, base, disp, extdisp);           ->break
ops(SHR):   putbyte(16_D3);        modrmmem(5, base, disp, extdisp);           ->break
ops( * ):   { normal stuff }
            putbyte(opvalue(opn)); modrmmem(reg - EAX, base, disp, extdisp );  ->break
break:

        listpreamble
        printstring(opname(opn))
        space
        printmemref(base, disp)
        printsymbol(',')
        printstring(reg32name(reg))
        newline

        writeifrecord(IF OBJ)
    %end

    ! Plant an 8 bit Memory <- Reg operation
    ! Both BASE and REG are internal ID's, not actual register numbers
    %routine dumpmr8( %integer opn, base, disp, extdisp, reg )
        %switch ops(DEC:JMP)

        ->ops(opn)

ops(SHL):   { special "shift by CL" }
            putbyte(16_D2);         modrmmem(4, base, disp, extdisp);          ->break
ops(SHR):   putbyte(16_D2);         modrmmem(5, base, disp, extdisp);          ->break
ops( * ):   { normal stuff }
            putbyte(op8value(opn)); modrmmem(reg - AL, base, disp, extdisp );  ->break
break:

        listpreamble
        printstring(opname(opn))
        space
        printmemref(base, disp)
        printsymbol(',')
        printstring(reg8name(reg))
        newline

        writeifrecord(IF OBJ)
    %end

    ! Plant a 32 bit Reg <- Memory operation
    ! Both BASE and REG are internal ID's, not actual register numbers
    %routine dumprm( %integer opn, reg, base, disp, extdisp )
        %integer reloc

        ! We optimise the fairly common instruction MOV EAX,[disp] with
        ! the special short-form quirk of the 8086...
        reloc = base>>4

        %if (reg = EAX) %and (opn = MOV) %and (base&15 = 0) %start
            putbyte(16_A1)
            relocateoffset(reloc, disp, extdisp)
        %finish %else %if (opn = MOVSX) %start
            displayhint(reg) = 0

            ! MOVSX requires a prefix of 0F
            putbyte(16_0F)
            putbyte(opvalue(opn))
            modrmmem(reg - EAX, base, disp, extdisp)
        %finish %else %start
            displayhint(reg) = 0

            putbyte(opvalue(opn)+2)
            modrmmem(reg - EAX, base, disp, extdisp)
        %finish

        listpreamble
        printstring(opname(opn))
        space
        printstring(reg32name(reg))
        printsymbol(',')
        printmemref(base, disp)
        newline

        writeifrecord(IF OBJ)
    %end

    ! Plant an 8 bit Reg <- Memory operation
    ! Both BASE and REG are internal ID's, not actual register numbers
    %routine dumprm8( %integer opn, reg, base, disp, extdisp )

        putbyte(op8value(opn)+2)
        modrmmem(reg - AL, base, disp, extdisp )

        listpreamble
        printstring(opname(opn))
        space
        printstring(reg8name(reg))
        printsymbol(',')
        printmemref(base, disp)
        newline

        writeifrecord(IF OBJ)
    %end

    ! Plant a word Reg <- Reg operation
    ! Both register parameters are internal ID's
    %routine dumprr( %integer opn, reg1, reg2 )
        %switch ops(DEC:JMP)

        displayhint(reg1) = 0

        ->ops(opn)

ops(SHL):   { special "shift by CL" }
            putbyte(16_D3);        modrmreg(4, reg1 - EAX);          ->break
ops(SHR):   putbyte(16_D3);        modrmreg(5, reg1 - EAX);          ->break
ops( * ):   { normal stuff }
            putbyte(opvalue(opn)); modrmreg(reg2 - EAX, reg1 - EAX); ->break
break:

        listpreamble
        printstring(opname(opn))
        space
        printstring(reg32name(reg1))
        printsymbol(',')
        printstring(reg32name(reg2))
        newline

        writeifrecord(IF OBJ)
    %end

    ! Plant a special Reg32 <- Reg16 operation
    ! Both register parameters are internal ID's
    %routine dumprrx( %integer opn, reg1, reg2 )
        %switch ops(DEC:JMP)

        displayhint(reg1) = 0

        ->ops(opn)

ops(MOVSX): putbyte(16_0F); ! MOVSX requires a prefix
            putbyte(opvalue(opn)); modrmreg(reg2 - AX, reg1 - EAX); ->break
ops( * ):   { unexpected operation }                                ->done
break:

        listpreamble
        printstring(opname(opn))
        space
        printstring(reg32name(reg1))
        printsymbol(',')
        printstring(reg16name(reg2))
        newline

        writeifrecord(IF OBJ)
done:
    %end

    ! Routine is un-used but is retained for possible future use
    %routine dumprr8( %integer opn, reg1, reg2 )
        %switch ops(DEC:JMP)

        ->ops(opn)

ops(SHL):   { special "shift by CL" }
            putbyte(16_D2);         modrmreg(4, reg1 - AL);         ->break
ops(SHR):   putbyte(16_D2);         modrmreg(5, reg1 - AL);         ->break
ops( * ):   { normal stuff }
            putbyte(op8value(opn)); modrmreg(reg2 - AL, reg1 - AL); ->break
break:

        listpreamble
        printstring(opname(opn))
        space
        printstring(reg8name(reg1))
        printsymbol(',')
        printstring(reg8name(reg2))
        newline

        writeifrecord(IF OBJ)
    %end

    ! Register immediate operations - can be MOV, Math, or Shift
    ! The immediate operand may be a relocated offset as part of
    ! an address calculation
    %routine dumprioffset( %integer opn, reg, reloc, immed, extdisp )
        %integer subop
        %switch ops(MOV:SHR)

        displayhint(reg) = 0

        ! because we pass around the or-able version
        reloc = reloc >> 4

        %if (reg = EAX) %and (opn <= XOR) %start
            putbyte(aximmediatevalue(opn))
            relocateoffset(reloc, immed, extdisp)
            ->break
        %else
            ->ops(opn)
        %finish

ops(MOV):
        putbyte(16_B8 + reg - EAX)
        relocateoffset(reloc, immed, extdisp )
                                                       ->break
ops(ADD):
        subop = 0
        %if issmall(immed) %and (reloc = 0) %start
            putbyte(16_83)
            modrmreg(subop, reg - EAX)
            putbyte(immed&255)
        %else
            putbyte(16_81)
            modrmreg(subop, reg - EAX)
            relocateoffset(reloc, immed, extdisp )
        %finish
                                                       ->break
ops(ADC):
        subop = 2
        %if issmall(immed) %and (reloc = 0) %start
            putbyte(16_83)
            modrmreg(subop, reg - EAX)
            putbyte(immed&255)
        %else
            putbyte(16_81)
            modrmreg(subop, reg - EAX)
            relocateoffset(reloc, immed, extdisp )
        %finish
                                                       ->break
ops(CMP):
        subop = 7
        %if issmall(immed) %and (reloc = 0) %start
            putbyte(16_83)
            modrmreg(subop, reg - EAX)
            putbyte(immed&255)
        %else
            putbyte(16_81)
            modrmreg(subop, reg - EAX)
            relocateoffset(reloc, immed, extdisp )
        %finish
                                                       ->break
ops(SUB):
        subop = 5
        %if issmall(immed) %and (reloc = 0) %start
            putbyte(16_83)
            modrmreg(subop, reg - EAX)
            putbyte(immed&255)
        %else
            putbyte(16_81)
            modrmreg(subop, reg - EAX)
            relocateoffset(reloc, immed, extdisp )
        %finish
                                                       ->break
ops(AND):
        subop = 4
        putbyte(16_81)
        modrmreg(subop, reg - EAX)
        relocateoffset(reloc, immed, extdisp )
                                                       ->break
ops(OR):
        subop = 1
        putbyte(16_81)
        modrmreg(subop, reg - EAX)
        relocateoffset(reloc, immed, extdisp )
                                                       ->break
ops(XOR):
        subop = 6
        putbyte(16_81)
        modrmreg(subop, reg - EAX)
        relocateoffset(reloc, immed, extdisp )
                                                       ->break
ops(SHL):
        subop = 4
        %if (immed = 1) %start
            ! special shift-by-one instruction
            putbyte(16_D1)
            modrmreg(subop, reg - EAX)
        %else
            putbyte(16_C1)
            modrmreg(subop, reg - EAX)
            putbyte(immed)
        %finish
                                                       ->break
ops(SHR):
        subop = 5
        %if (immed = 1) %start
            ! special shift-by-one instruction
            putbyte(16_D1)
            modrmreg(subop, reg - EAX)
        %else
            putbyte(16_C1)
            modrmreg(subop, reg - EAX)
            putbyte(immed)
        %finish
                                                       ->break
break:
        listpreamble
        printstring(opname(opn))
        space
        printstring(reg32name(reg))
        printsymbol(',')
        %if (reloc # 0) %start
            printstring(relocname(reloc))
            printsymbol('+')
        %finish
        printsymbol('#')
        write(immed, 0)
        newline

        writeifrecord(IF OBJ)
    %end

    ! Register immediate operations - can be MOV, Math, or Shift
    %routine dumpri( %integer opn, reg, immed )
        %integer subop
        %switch ops(MOV:SHR)

        displayhint(reg) = 0

        %if (reg = EAX) %and (opn <= XOR) %start
            putbyte(aximmediatevalue(opn))
            ! plant code for a relocated (DATA/BSS/DISPLAY/EXTERNAL) code word
            putlong( immed )

            ->break
        %else
            ->ops(opn)
        %finish

ops(MOV):
        putbyte(16_B8 + reg - EAX)
        ! plant code for a relocated (DATA/BSS/DISPLAY/EXTERNAL) code word
        putlong( immed )
                                                       ->break
ops(ADD):
        subop = 0
        %if issmall(immed) %start
            putbyte(16_83)
            modrmreg(subop, reg - EAX)
            putbyte(immed&255)
        %else
            putbyte(16_81)
            modrmreg(subop, reg - EAX)
            ! plant code for a relocated (DATA/BSS/DISPLAY/EXTERNAL) code word
            putlong( immed )
        %finish
                                                       ->break
ops(ADC):
        subop = 2
        %if issmall(immed) %start
            putbyte(16_83)
            modrmreg(subop, reg - EAX)
            putbyte(immed&255)
        %else
            putbyte(16_81)
            modrmreg(subop, reg - EAX)
            ! plant code for a relocated (DATA/BSS/DISPLAY/EXTERNAL) code word
            putlong( immed )
        %finish
                                                       ->break
ops(CMP):
        subop = 7
        %if issmall(immed) %start
            putbyte(16_83)
            modrmreg(subop, reg - EAX)
            putbyte(immed&255)
        %else
            putbyte(16_81)
            modrmreg(subop, reg - EAX)
            ! plant code for a relocated (DATA/BSS/DISPLAY/EXTERNAL) code word
            putlong( immed )
        %finish
                                                       ->break
ops(SUB):
        subop = 5
        %if issmall(immed) %start
            putbyte(16_83)
            modrmreg(subop, reg - EAX)
            putbyte(immed&255)
        %else
            putbyte(16_81)
            modrmreg(subop, reg - EAX)
            ! plant code for a relocated (DATA/BSS/DISPLAY/EXTERNAL) code word
            putlong( immed )
        %finish
                                                       ->break
ops(AND):
        subop = 4
        putbyte(16_81)
        modrmreg(subop, reg - EAX)
        ! plant code for a relocated (DATA/BSS/DISPLAY/EXTERNAL) code word
        putlong( immed )
                                                       ->break
ops(OR):
        subop = 1
        putbyte(16_81)
        modrmreg(subop, reg - EAX)
        ! plant code for a relocated (DATA/BSS/DISPLAY/EXTERNAL) code word
        putlong( immed )
                                                       ->break
ops(XOR):
        subop = 6
        putbyte(16_81)
        modrmreg(subop, reg - EAX)
        ! plant code for a relocated (DATA/BSS/DISPLAY/EXTERNAL) code word
        putlong( immed )
                                                       ->break
ops(SHL):
        subop = 4
        %if (immed = 1) %start
            ! special shift-by-one instruction
            putbyte(16_D1)
            modrmreg(subop, reg - EAX)
        %else
            putbyte(16_C1)
            modrmreg(subop, reg - EAX)
            putbyte(immed)
        %finish
                                                       ->break
ops(SHR):
        subop = 5
        %if (immed = 1) %start
            ! special shift-by-one instruction
            putbyte(16_D1)
            modrmreg(subop, reg - EAX)
        %else
            putbyte(16_C1)
            modrmreg(subop, reg - EAX)
            putbyte(immed)
        %finish
                                                       ->break
break:
        listpreamble
        printstring(opname(opn))
        space
        printstring(reg32name(reg))
        printsymbol(',')
        printsymbol('#')
        write(immed, 0)
        newline

        writeifrecord(IF OBJ)
    %end

    ! Memory (long) immediate operations - can be MOV, Math, or Shift
    %routine dumpmi( %integer opn, base, disp, extdisp, immed )
        %integer subop
        %switch ops(MOV:SHR)

        ->ops(opn)

ops(MOV):
        putbyte(16_C7)
        modrmmem(0, base, disp, extdisp )
        ! plant code for a relocated (DATA/BSS/DISPLAY/EXTERNAL) code word
        putlong( immed )
                                                       ->break
ops(ADD):
        subop = 0
        %if issmall(immed) %start
            putbyte(16_83)
            modrmmem(subop, base, disp, extdisp )
            putbyte(immed&255)
        %else
            putbyte(16_81)
            modrmmem(subop, base, disp, extdisp )
            ! plant code for a relocated (DATA/BSS/DISPLAY/EXTERNAL) code word
            putlong( immed )
        %finish
                                                       ->break
ops(ADC):
        subop = 2
        %if issmall(immed) %start
            putbyte(16_83)
            modrmmem(subop, base, disp, extdisp )
            putbyte(immed&255)
        %else
            putbyte(16_81)
            modrmmem(subop, base, disp, extdisp )
            ! plant code for a relocated (DATA/BSS/DISPLAY/EXTERNAL) code word
            putlong( immed )
        %finish
                                                       ->break
ops(CMP):
        subop = 7
        %if issmall(immed) %start
            putbyte(16_83)
            modrmmem(subop, base, disp, extdisp )
            putbyte(immed&255)
        %else
            putbyte(16_81)
            modrmmem(subop, base, disp, extdisp )
            ! plant code for a relocated (DATA/BSS/DISPLAY/EXTERNAL) code word
            putlong( immed )
        %finish
                                                       ->break
ops(SUB):
        subop = 5
        %if issmall(immed) %start
            putbyte(16_83)
            modrmmem(subop, base, disp, extdisp )
            putbyte(immed&255)
        %else
            putbyte(16_81)
            modrmmem(subop, base, disp, extdisp )
            ! plant code for a relocated (DATA/BSS/DISPLAY/EXTERNAL) code word
            putlong( immed )
        %finish
                                                       ->break
ops(AND):
        subop = 4
        putbyte(16_81)
        modrmmem(subop, base, disp, extdisp )
        ! plant code for a relocated (DATA/BSS/DISPLAY/EXTERNAL) code word
        putlong( immed )
                                                       ->break
ops(OR):
        subop = 1
        putbyte(16_81)
        modrmmem(subop, base, disp, extdisp )
        ! plant code for a relocated (DATA/BSS/DISPLAY/EXTERNAL) code word
        putlong( immed )
                                                       ->break
ops(XOR):
        subop = 6
        putbyte(16_81)
        modrmmem(subop, base, disp, extdisp )
        ! plant code for a relocated (DATA/BSS/DISPLAY/EXTERNAL) code word
        putlong( immed )
                                                       ->break
ops(SHL):
        subop = 4
        %if (immed = 1) %start
            ! special shift-by-one instruction
            putbyte(16_D1)
            modrmmem(subop, base, disp, extdisp )
        %else
            putbyte(16_C1)
            modrmmem(subop, base, disp, extdisp )
            putbyte(immed)
        %finish
                                                       ->break
ops(SHR):
        subop = 5
        %if (immed = 1) %start
            ! special shift-by-one instruction
            putbyte(16_D1)
            modrmmem(subop, base, disp, extdisp )
        %else
            putbyte(16_C1)
            modrmmem(subop, base, disp, extdisp )
            putbyte(immed)
        %finish
                                                       ->break
break:
        listpreamble
        printstring(opname(opn))
        ! otherwise it's ambiguous for the reader
        printstring(" DWORD PTR ")
        printmemref(base, disp)
        printsymbol(',')
        printsymbol('#')
        write(immed, 0)
        newline

        writeifrecord(IF OBJ)
    %end

    ! Memory (8 bit) immediate operations - can be MOV, Math, or Shift
    %routine dumpmi8( %integer opn, base, disp, extdisp, immed )
        %integer subop
        %switch ops(MOV:SHR)

        ->ops(opn)

ops(MOV):
        subop = 0
        putbyte(16_C6)
        modrmmem(subop, base, disp, extdisp )
        putbyte(immed&255)
                                                       ->break
ops(ADD):
        subop = 0
        putbyte(16_80)
        modrmmem(subop, base, disp, extdisp )
        putbyte(immed&255)
                                                       ->break
ops(ADC):
        subop = 2
        putbyte(16_80)
        modrmmem(subop, base, disp, extdisp )
        putbyte(immed&255)
                                                       ->break
ops(CMP):
        subop = 7
        putbyte(16_80)
        modrmmem(subop, base, disp, extdisp )
        putbyte(immed&255)
                                                       ->break
ops(SUB):
        subop = 5
        putbyte(16_80)
        modrmmem(subop, base, disp, extdisp )
        putbyte(immed&255)
                                                       ->break
ops(AND):
        subop = 4
        putbyte(16_80)
        modrmmem(subop, base, disp, extdisp )
        putbyte(immed&255)
                                                       ->break
ops(OR):
        subop = 1
        putbyte(16_80)
        modrmmem(subop, base, disp, extdisp )
        putbyte(immed&255)
                                                       ->break
ops(XOR):
        subop = 6
        putbyte(16_80)
        modrmmem(subop, base, disp, extdisp )
        putbyte(immed&255)
                                                       ->break
ops(SHL):
        subop = 4
        %if (immed = 1) %start
            ! special shift-by-one instruction
            putbyte(16_D0)
            modrmmem(subop, base, disp, extdisp )
        %else
            putbyte(16_C0)
            modrmmem(subop, base, disp, extdisp )
            putbyte(immed)
        %finish
                                                       ->break
ops(SHR):
        subop = 5
        %if (immed = 1) %start
            ! special shift-by-one instruction
            putbyte(16_D0)
            modrmmem(subop, base, disp, extdisp )
        %else
            putbyte(16_C0)
            modrmmem(subop, base, disp, extdisp )
            putbyte(immed)
        %finish
                                                       ->break
break:
        listpreamble
        printstring(opname(opn))
        ! otherwise it's ambiguous for the reader
        printstring(" BYTE PTR ")
        printmemref(base, disp)
        printsymbol(',')
        printsymbol('#')
        write(immed, 0)
        newline

        writeifrecord(IF OBJ)
    %end

    ! Finally, a catch-all that recasts operations using generic
    ! Var Stack structures
    ! Plant a 32 bit Reg <- Var operation
    %routine dumprv( %integer opn, reg, %record(stackfm)%name v )
        %switch form(0:15)

        -> form(v_form&15)
form(V in R):   dumprr(opn, reg, v_base);                             -> esac
form(V in S):   dumprm(opn, reg, v_base!v_scope, v_disp, v_extdisp ); -> esac
form(constant): dumprioffset(opn, reg, v_scope, v_disp, v_extdisp );  -> esac
form( * ):      abort("Bad Address Mode-dumprv")
esac:
    %end

    !JDM JDM added code to move data into an 8-bit reg
    ! Finally, a catch-all that recasts operations using generic
    ! Var Stack structures
    ! Plant an 8-bit Reg <- Var operation
    %routine dumpr8v( %integer opn, reg, %record(stackfm)%name v )
        %switch form(0:15)

        -> form(v_form&15)
form(V in R):   dumprr8(opn, reg, v_base);                            -> esac
form(V in S):   dumprm8(opn, reg, v_base!v_scope, v_disp, v_extdisp ); -> esac
form(constant): dumprioffset(opn, reg, v_scope, v_disp, v_extdisp );  -> esac
form( * ):      abort("Bad Address Mode-dumpr8v")
esac:
    %end
    ! Another special dumper - the only "Unary" operation that
    ! takes an immediate operand is PUSH
    %routine dumppushi( %integer reloc, immed, extdisp )

        ! because we pass around the or-able version
        reloc = reloc >> 4

        %if (reloc = 0) %and issmall(immed) %start
            putbyte(16_6A)
            putbyte(immed&255)
        %else
            putbyte(16_68)
            relocateoffset(reloc, immed, extdisp )
        %finish

        listpreamble
        printstring("PUSH")
        space
        %if (reloc # 0) %start
            printstring(relocname(reloc))
            printsymbol('+')
        %finish
        printsymbol('#')
        write(immed, 0)
        newline

        writeifrecord(IF OBJ)
    %end

    %routine dumpvpush(%record(stackfm)%name v)
        %switch form(0:15)

        -> form(v_form&15)
form(V in R):   dumpur(PUSH, v_base);                             -> esac
form(V in S):   dumpum(PUSH, v_base!v_scope, v_disp, v_extdisp ); -> esac
form(constant): dumppushi(v_scope, v_disp, v_extdisp );           -> esac
form( * ):      abort("Bad Push Mode-dumpvpush")
esac:
    %end
      
    !----------------------------------------------------------
    ! Floating point instructions - much simpler since there are
    ! only two forms - RR and RM

    %conststring(10)%array flopname(FILD:FLDPI) =
    "FILD", "FLD DWORD", "FLD QWORD", "FISTP",
    "FSTP DWORD", "FSTP QWORD", "FADDP", "FSUBP",
    "FSUBRP", "FMULP", "FDIVP", "FDIVRP",
    "FCOMPP", "FCHS", "FABS",
    "FSTSW AX", "FLDZ", "FLDPI"

    ! The prefix opcode
    %constbyteintegerarray flprefix(FILD:FLDPI) =
    16_DB, 16_D9, 16_DD, 16_DB,
    16_D9, 16_DD, 16_DE, 16_DE,
    16_DE, 16_DE, 16_DE, 16_DE,
    16_DE, 16_D9, 16_D9,
    16_DF, 16_D9, 16_D9

    ! The function selector to put in the field in the second byte
    ! (or the second byte)
    %constbyteintegerarray flindex(FILD:FLDPI) =
    16_00, 16_00, 16_00, 16_03,
    16_03, 16_03, 16_C0, 16_E8,
    16_E0, 16_C8, 16_F8, 16_F0,
    16_D9, 16_E0, 16_E1,
    16_E0, 16_EE, 16_EB

    ! Plant a Floating Point Reg <- Memory operation
    ! BASE is an internal ID, not actual register number
    ! Destination register is implicitly the stack top
    %routine dumpfloprm( %integer opn, base, disp, extdisp )

        %if (opn <= FLDQ) %start
            ! a load type
            fpu stack = fpu stack + 1
            %if (fpu stack > 8) %then abort("FPU Stack Overflow")
        %else
            fpu stack = fpu stack - 1
            %if (fpu stack < 0) %then abort("FPU Stack Underflow")
        %finish

        ! JDM JDM old code used with external 8087 numeric co-processor
!        putbyte(16_9B);         ! we prepend a WAIT to everything
        putbyte(flprefix(opn))
        modrmmem(flindex(opn), base, disp, extdisp )

        listpreamble
        printstring(flopname(opn))
        space
        printmemref(base, disp)
        newline

        writeifrecord(IF OBJ)
    %end

    ! Plant a Floating Point Reg <- Reg operation
    ! Both register parameters are internal ID's that we
    ! convert to stack offsets
    %routine dumpfloprr( %integer opn, reg1, reg2 )
        %integer top

        top = fpustack + (FR0 - 1)

        %if (reg2 # top) %then abort("FPU Stack Address")

        %if (opn < FCHS) %start
            ! two operands - will pop one
            fpu stack = fpu stack - 1
            ! COMPP pops both registers
            %if (opn = FCMP) %then fpu stack = fpu stack - 1
            %if (fpu stack < 0) %then abort("FPU Stack Underflow")
        %finish

        ! JDM JDM old code used with external 8087 numeric co-processor
!        putbyte(16_9B);         ! we prepend a WAIT to everything
        putbyte(flprefix(opn))
        putbyte(flindex(opn)!(top - reg1))

        listpreamble
        printstring(flopname(opn))
        space
        printstring("ST(")
        write(top-reg1, 0)
        printstring("),ST")
        newline

        writeifrecord(IF OBJ)
    %end

    ! Plant a "special" floating point operation
    %routine dumpflopspec(%integer opn)

        %if (opn >= FLDZ) %start
            ! load a constant
            fpu stack = fpu stack + 1
            %if (fpu stack > 8) %then abort("FPU Stack Overflow")
        %finish

        ! JDM JDM old code used with external 8087 numeric co-processor
!        putbyte(16_9B);         ! we prepend a WAIT to everything
        putbyte(flprefix(opn))
        putbyte(flindex(opn))

        listpreamble
        printstring(flopname(opn))
        newline

        writeifrecord(IF OBJ)
    %end

    %routine dumpjump( %integer opn, labelid )
        ! Firstly we fake up some pseudo-code conventional assembler
        ! (with a zero jump offset) to feed into the listing pipe.
        ! The genuine instruction code is generated after the listing
        ! pseudo-code
        ! This is a case where the listing pipe and code pipes contain
        ! different sequences.
        ! Hence the use of putlistbyte and putcodebyte routines
        ! rather than putbyte
        ! Start listing pseudo-code
        putlistbyte(opvalue(opn))
        putlistbyte(0)

        %if (opn = CALL) %start
            putlistbyte(0)
        %finish

        listpreamble
        printstring(opname(opn))
        space
        { JDM JDM start new code }
        %if (opn = CALL) %start
            ! JDM JDM See if we can show the routine name
            printstring( "'" )
            %if (top_var no = 0) %start
                printstring( "$L" )
                write(labelid,0)
            %finish %else %start
                printstring( get symbol name(top_var no) )
            %finish
            printstring( "' (INTERNAL ")
            printsymbol('L')
            write(labelid,0)
            printstring(" )")
        %else
            printsymbol('L')
            write(labelid,0)
        %finish
        { JDM JDM end new code }
        newline
        ! End listing pseudo-code

        ! Start actual instruction code
        ! Now for the actual code to be added to the instruction pipe.
        ! We instead load the instruction pipe with an IBJ symbol directive
        %if (opn = JMP) %start
            putcodetag( labelid )
            writeifrecord(IF JUMP)
        %finish %else %if (opn = CALL) %start
! JDM JDM replaced use of IF CALL command by IF REFLABEL command
! old code retained Just-in-case
!           ! Generated code using IF CALL ibj command
!           putcodetag( labelid )
!           writeifrecord(IF CALL)

            ! JDM JDM Generated code using IF REFLABEL ibj command
            ! plant the CALL code
            ! call with relative address
            putcodebyte( 16_E8 )
            writeifrecord(IF OBJ)

            ! plant the relative address of the label
            putcodetag( labelid )

            ! JDM JDM set offset to zero
            putcodeword( 0 )
            writeifrecord(IF REFLABEL)
        %finish %else %start
            ! not an unconditional JMP or a CALL
            ! assume it is a conditional JMP (i.e. JE,JNE, etc.)
            putcodebyte(opn - JE)
            putcodetag( labelid )
            writeifrecord(IF JCOND)
        %finish
        ! End actual instruction code

        ! finally, calls may trash registers...
        %if (opn = CALL) %start
            displayhint(EBX) = 0
            displayhint(ESI) = 0
            displayhint(EDI) = 0
        %finish
    %end

    ! call the n'th external routine we've spec'ed
    %routine dumpextcall(%integer labelid)

        displayhint(EBX) = 0
        displayhint(ESI) = 0
        displayhint(EDI) = 0

        ! plant the "CALL" instruction
        putbyte(opvalue(CALL))

        writeifrecord(IF OBJ)

        putlistword( labelid )
        putcodeword( labelid )
        putcodeword( 0 )        { unused 16-bit offset to the label }

        listpreamble
        ! JDM JDM attempt to show external routine name
        printstring("CALL ")
        %if (labelid <= lastperm) %start
            ! This is an internal "perm" routine
            ! So, show the name
            printstring("'".permname(labelid)."'")
        %else
            ! JDM JDM this is an external routine
            %if (labelid > lasthidden) %start
                printstring("'".get symbol name(top_var no)."'")
            %finish %else %start
                printstring("'".hidden name(labelid - lastperm)."'")
            %finish
        %finish
        printstring(" (EXTERN ")
        write(labelid,0)
        printstring(")")
        newline
        ! JDM JDM end attempt

        ! We have put the 2 bytes of the label tag into the code pipe
        ! However we indicate that this is really a 32-bit (word)
        writeifrecord(IF REFEXT)
    %end

    %routine dumplabel(%integer labelid)

        select output(listout)
        space
        writehex(nextcad, 4)
        spaces(22)
        printsymbol('L')
        write(labelid,0)
        printstring("  EQU $")
        newline

        putcodetag( labelid )
        writeifrecord(IF LABEL)

        displayhint(EBX) = 0
        displayhint(ESI) = 0
        displayhint(EDI) = 0
    %end

    %routine dumpstaticalloc(%integer which, level, %string(255)%name name)
        %string(255) fixupname

        ! we pretend to dump "C8 00 00 lev  ENTER 0000,lev"
        putlistbyte(16_C8)
        putlistbyte(16_00)
        putlistbyte(16_00)
        putlistbyte(level)

        listpreamble
        printstring("ENTER 0000,")
        write(level,0)
        newline

        ! but we actually plant a special pass 2 directive (IF FIXUP)
        putcodetag( which )
        putcodebyte( level )
        ! we also pass the (truncated) name of the routine
        !  - for pass3 diagnostic use
        ! Size limit of 16 due to symbol name constraint
        ! within the COFF/ELF 32-bit object file format?

        ! Get a clean copy of the "name"
        ! We can't use the original string since we are possibly
        ! going to truncate the string and we'll still need the
        ! original string
        fixupname = name

        ! Truncate the fixupname (= name) to at most 16 chars
        %if (length(fixupname) > 16) %then length(fixupname) = 16

        ! Yes, we could just copy the first 16 chars into the code buffer
        ! but this way we reuse the existing routine "putcodestring"
        ! to send the chars of the possibly truncated name into the pipe code
        putcodestring(fixupname)

        writeifrecord(IF FIXUP)
    %end

    ! Pass 3 goes back and plants the correct preamble code for
    ! the static allocation based on this directive, and also fills
    ! in the event trap block as appropriate
    %routine dumpstaticfill(%integer which, size, events, evep, evfrom)

        ! Only insert the code bytes.
        ! The list bytes form part of the static storage
        putcodeword( which )

        ! Size is actually a negative value
        ! So we AND size with a 2 byte (=word) version of (-1)
        ! Then store the 16-bit result in the code pipe
        putcodeword( size&16_FFFF )

        putcodeword( events )
        putcodeword( evep )
        putcodeword( evfrom )

        writeifrecord(IF SETFIX)
    %end

    ! dump words for the constant segment or the switch segment
    ! Adjusts CAD so that the diagnostic listing looks sensible
    %routine dumpcsword( %integer word, which )
        %integer tag, tmpcad, hi, lo
        %owninteger cptr = 0
        %owninteger sptr = 0

        tmpcad = next cad
        %if (which = IF SWTWORD) %start
            tag = IF SWTWORD
            next cad = sptr
            sptr = sptr + 2
        %finish %else %if (which = IF COTWORD) %start
            tag = IF COTWORD
            next cad = cptr
            cptr = cptr + 2
        %finish

        putcodeword(word)

        hi = word >> 8
        lo = word&255
        listpreamble
        printstring("db ")
        writehex(lo, 2)
        printsymbol(',')
        writehex(hi, 2)
        printstring(" ; ")
        %if (32 < lo < 127) %then printsymbol(lo) %else printsymbol('.')
        %if (32 < hi < 127) %then printsymbol(hi) %else printsymbol('.')
        newline

        writeifrecord(tag)

        ! restore the real CAD
        nextcad = tmp cad
    %end

    ! dump words for the data segment
    ! Adjusts CAD so that the diagnostic listing looks sensible
    %routine dumpdatword( %integer word, %integer count )
        %integer tmpcad, hi, lo
        %owninteger dptr = 0

        tmpcad = next cad
        next cad = dptr
        dptr = dptr + 2*count

        ! populate the DATWORD record
        putcodeword(word)
        putcodeword(count)

        writeifrecord(IF DATWORD)

        ! now populate the code listing
        hi = word >> 8
        lo = word&255
        listpreamble
        %if (count = 1) %start
            printstring("db ")
        %finish %else %start
            printstring("blk(".itos(count,0).") ")
        %finish
        writehex(lo, 2)
        printsymbol(',')
        writehex(hi, 2)
        printstring(" ; ")
        %if (32 < lo < 127) %then printsymbol(lo) %else printsymbol('.')
        %if (32 < hi < 127) %then printsymbol(hi) %else printsymbol('.')
        newline

        ! restore the real CAD
        nextcad = tmp cad
    %end

    ! tell the object file maker what source line we are on
    %routine dumplinenumber(%integer line)
        putcodeword( line )
        writeifrecord(IF LINE)
    %end

    ! tell the object maker the source file name
    %routine dumpsourcename(%string(255) filename)

        putcodestring(filename)
        writeifrecord(IF SOURCE)

    %end

    ! Plant a request to the linker for the external name, and
    ! return an index number to refer to it with in future
    %integerfn externalref(%string(255) extname)
        %owninteger nextextref=1

        putcodestring(extname)
        writeifrecord(IF REQEXT)

        nextextref = nextextref + 1
        %result = nextextref - 1
    %end

    ! tell the linker about an external definition
    %routine fill external(%integer seg, %string(255) extname)

        putcodestring(extname)
        %if (seg = CODE) %start
            writeifrecord(IF DEFEXTCODE)
        %else
            ! JDM JDM pass3 amended to allow external data
            writeifrecord(IF DEFEXTDATA)
        %finish
    %end

    !------------------------------------------------------
    ! Constant table utility routines
    !
    ! Rather than dump literal constants as they occur,
    ! we collect them in a table.
    ! Whenever the compiler wants any kind of literal,
    ! we look to see if we already have it.
    ! Note this automatically solves re-use of things like
    ! floating point constants, string newline, and fixed array dope vectors.
    ! When the table starts to get fairly full, we flush it.
    ! Obviously that means in a large program we might not
    ! actually get full re-use of constants after we've flushed,
    ! but the idea is sound.
    !
    ! For the convenience of the caller, several versions of
    ! pretty much the same thing are provided.
    !------------------------------------------------------
    %constinteger cot size = 2000
    %ownbyteintegerarray contable(0:cot size)
    %owninteger cotp = 0

    ! updated on a flush
    %owninteger cotoffset = 0

    %routine flushcot
        %integer i

        ! We output a position hint to the diagnostic stream
        ! Note that although this is intended to look like
        ! 8086 assembly directives the real work is done by
        ! pass 3 - this is only to guide the human reader as
        ! to what is going on

        selectoutput(listout)
        printstring("      _TEXT  ENDS")
        newline
        printstring("      CONST  SEGMENT WORD PUBLIC 'CONST'")
        newline

        i = 0
        %while i < cotp %cycle
            dumpcsword( (contable(i+1) << 8) ! contable(i), IF COTWORD )
            i = i + 2
        %repeat

        ! Update the pointers
        cotp = 0
        cotoffset = cotoffset + i

        ! and send another hint
        selectoutput(listout)
        printstring("      CONST  ENDS")
        newline
        printstring("      _TEXT  SEGMENT WORD PUBLIC 'CODE'")
        newline

    %end

    ! return the offset in the const segment of a byte
    ! with value b
    %integerfn getcotb(%byteinteger b)
        %integer i

        i = 0
        %while (i < cotp) %cycle
            %if (contable(i) = b) %then %result = i + cotoffset
            i = i + 1
        %repeat

        ! value wasn't there
        %if (cotp = cotsize) %then flushcot

        contable(cotp) = b
        cotp = cotp + 1
        %result = (cotp - 1) + cotoffset
    %end

    ! return the offset in the const segment of a word
    ! with value w
    %integerfn getcotw(%integer w)
        %integer i, cw

        i = 0
        %while (i < cotp-3) %cycle
            cw = 0
            cw = cw!(contable(i)<<0)
            cw = cw!(contable(i+1)<<8)
            cw = cw!(contable(i+2)<<16)
            cw = cw!(contable(i+3)<<24)
            %if (cw = w) %then %result = i + cotoffset
            i = i + word size
        %repeat

        ! value wasn't there - first make sure there is space
        %if (cotp > cotsize-word size) %then flushcot

        ! now round off the COT
        cotp = (cotp + align) & (\align)

        %for i=1,1,word size %cycle
            contable(cotp) = w&255
            w = w >> 8
            cotp = cotp + 1
        %repeat

        %result = (cotp - word size) + cotoffset
    %end

    ! return the offset in the const segment of double precision real number
    %integerfn getcotdouble( %longreal double )
        %integer i

        i = 0
        %while (i < cotp-7) %cycle
            %if      (contable(i+0) = byteinteger(addr(double)+0)) %c
                %and (contable(i+1) = byteinteger(addr(double)+1)) %c
                %and (contable(i+2) = byteinteger(addr(double)+2)) %c
                %and (contable(i+3) = byteinteger(addr(double)+3)) %c
                %and (contable(i+4) = byteinteger(addr(double)+4)) %c
                %and (contable(i+5) = byteinteger(addr(double)+5)) %c
                %and (contable(i+6) = byteinteger(addr(double)+6)) %c
                %and (contable(i+7) = byteinteger(addr(double)+7)) %c
            %then %result = i + cotoffset
            i = i + 4
        %repeat

        ! value wasn't there - first make sure there is space
        %if (cotp > cotsize-8) %then flushcot

        ! now round off the COT
        cotp = (cotp + align) & (\align)

        %for i=0,1,7 %cycle
            contable(cotp) = byteinteger(addr(double)+i)
            cotp = cotp + 1
        %repeat

        %result = (cotp - 8) + cotoffset
    %end

    ! return the offset in the const segment of a quad word (==4*32 bits)
    ! with value q0:q1:q2:q3 (lo to hi)
    %integerfn getcot4(%integer q0, q1, q2, q3)
        %integer i, cw0, cw1, cw2, cw3

        i = 0
        cw0 = 0
        cw0 = cw0!(contable(i+0)<<0)
        cw0 = cw0!(contable(i+1)<<8)
        cw0 = cw0!(contable(i+2)<<16)
        cw0 = cw0!(contable(i+3)<<24)

        cw1 = 0
        cw1 = cw1!(contable(i+4)<<0)
        cw1 = cw1!(contable(i+5)<<8)
        cw1 = cw1!(contable(i+6)<<16)
        cw1 = cw1!(contable(i+7)<<24)

        cw2 = 0
        cw2 = cw2!(contable(i+8)<<0)
        cw2 = cw2!(contable(i+9)<<8)
        cw2 = cw2!(contable(i+10)<<16)
        cw2 = cw2!(contable(i+11)<<24)
        %while i < cotp-15 %cycle
            cw3 = 0
            cw3 = cw3!(contable(i+12)<<0)
            cw3 = cw3!(contable(i+13)<<8)
            cw3 = cw3!(contable(i+14)<<16)
            cw3 = cw3!(contable(i+15)<<24)

            %if      (cw0 = q0) %c
                %and (cw1 = q1) %c
                %and (cw2 = q2) %c
                %and (cw3 = q3) %then %result = i + cotoffset
            i = i + word size
            cw0 = cw1
            cw1 = cw2
            cw2 = cw3
        %repeat

        ! value wasn't there - first make sure there is space
        %if (cotp > cotsize - 16) %then flushcot

        ! now round off the COT
        cotp = (cotp + align) & (\align)

        %for i=1,1,word size %cycle
            contable(cotp) = q0&255
            q0 = q0 >> 8
            cotp = cotp + 1
        %repeat

        %for i=1,1,word size %cycle
            contable(cotp) = q1&255
            q1 = q1 >> 8
            cotp = cotp + 1
        %repeat

        %for i=1,1,word size %cycle
            contable(cotp) = q2&255
            q2 = q2 >> 8
            cotp = cotp + 1
        %repeat

        %for i=1,1,word size %cycle
            contable(cotp) = q3&255
            q3 = q3 >> 8
            cotp = cotp + 1
        %repeat

        %result = (cotp - 16) + cotoffset
    %end

    %owninteger null string = -1

    ! get an index into the constant table for the string literal
    ! in the array s
    %integerfn getcots( %byteintegerarrayname b )
        %integer i, first, slen, match

        slen = b(0)

        ! We optimise the Null String "" in comparisons, so we remember
        ! the location here
        %if (slen = 0) %start
            null string = getcotb(0)
            %result = null string
        %finish

        ! offset to search in contable
        first = 0

        %while (first + slen < cotp) %cycle
            ! so long as there are that many bytes left
            match = 1
            ! Simple check of string lengths
            %if (slen # contable(first)) %start
                match = 0
                %exit
            %finish
            ! ok, so lengths match but do the contents
            %for i = 1, 1, slen %cycle
                %if (b(i) # contable(first + i)) %start
                    match = 0
                    %exit
                %finish
            %repeat
            %if (match = 1) %then %result = first + cotoffset

            ! try the next solution
            first = first + 1
        %repeat

        ! if we get here, it wasn't already in the constant table
        ! Ok, so will we overflow the buffer
        %if (cotp + slen + 1) >= cotsize %then flushcot

        ! dump the string length
        first = cotp
        contable(cotp) = slen
        cotp = cotp + 1
        ! Now, dump the string contents
        %for i = 1,1,slen %cycle
            contable(cotp) = b(i)
            cotp = cotp + 1
        %repeat
        %result = first + cotoffset
    %end

    !------------------------------------------------------
    ! Data segment utility routines
    !
    ! Unlike constants, we can't re-use data segment items,
    ! which makes this much simpler.  We still accumulate
    ! the bytes in a table because (1) we can make life
    ! more efficient for Pass 3 that way and (2) by collecting
    ! the bytes together we can produce more convincing debug
    ! code listings, especially for programs that don't need
    ! to flush the table in the middle of the code.
    ! Note that because data segment offsets are used directly
    ! as variable displacements, our pointer DATATP doesn't
    ! wrap like the COTP does, and instead we subtract the
    ! offset before we use it...
    !------------------------------------------------------

    ! Size in bytes of data segment table
    %constinteger datat limit = 1999
    %byteintegerarray datat(0:datat limit)

    ! pointer to next data segment byte
    %owninteger datatp = 0

    ! updated on a flush
    %owninteger datat offset = 0

    ! Flush the accumulated data table
    %routine flush data
        %integer i, limit
        %integer v1,v2,count

        ! We output a position hint to the diagnostic stream

        selectoutput(listout)
        printstring("            ENDS")
        newline
        printstring("      DATA  SEGMENT WORD PUBLIC 'DATA'")
        newline

        i = 0
        limit = datatp - datat offset
        count = 0
        %while i < limit %cycle
!            ! JDM JDM DANGER ! in line below is a Bitwise OR not a comment
!            dumpdatword(( datat(i+1) << 8) ! datat(i), 1 )

            ! remember the current datword
            v2 = ( datat(i+1) << 8) ! datat(i)
            %if (count = 0) %start
                ! empty count so remember the current dataword in v1 buffer
                ! and start the count
                v1 = v2
                count = 1
            %finish %else %if (v1 = v2) %start
                ! we have a repeated datword
                ! so increment the buffer count
                count = count + 1
            %finish %else %start
                ! end of the current repeated datword
                ! so output the repeated datword sequence
                dumpdatword( v1, count )
                ! start a new datword sequence
                ! remember the datword and start a new count
                v1 = v2
                count = 1
            %finish
            i = i + 2;
        %repeat

        ! Ensure we output any remaining datwords
        %if (count > 0) %start
            dumpdatword( v1, count )
        %finish

        datat offset = datat p

        ! and send another hint
        selectoutput(listout)
        printstring("      DATA    ENDS")
        newline
    %end

    !                                                  >> GBYTE <<
    ! Simple byte in data segment
    %routine  gbyte(%integer  n)

        flush data %if (datatp - datat offset > datat limit)
        datat(datatp - datat offset) = n & 255;
        datatp = datatp + 1
    %end

    !                                                  >> GPUT <<
    ! Put a word into data segment
    %routine  gput(%integer  n)
        %integer i

        %for i=1,1,word size %cycle
            gbyte(n)
            n = n >> 8;
        %repeat
    %end

    !                                                  >> GFIX <<
    ! round off the data-segment pointer for alignment
    %routine  gfix(%integer align)
        gbyte(0) %while (datatp&align # 0)
    %end

    !-----------------------------------------------------
    ! The last table we collect as we go along is the switch
    ! table.  We don't provide individual routines to fill
    ! it in, but for neatness we provide this routine to send
    ! the contents to pass 3

    %routine flush switch
        %integer i

        select output(listout)
        printstring("              ENDS")
        newline
        printstring("      _SWTAB  SEGMENT WORD PUBLIC '_SWTAB'")
        newline
        i = 0
        %while i < swtp %cycle
            dumpcsword(swtab(i), IF SWTWORD)
            i = i + 1
        %repeat

        ! and send another hint
        selectoutput(listout)
        printstring("      _SWTAB   ENDS")
        newline
    %end

    !-------------------------------------------------------------
    ! Print the source code lines up to the indicated line
    ! number - these will interleave with the diagnostic assembly
    ! output
    %owninteger echoline = 0

    %routine echo source line
        %integer ch
        %owninteger source eof = 0

        ! update the count even if there's no input
        echoline = echoline + 1

        ! silently ignore lack of source file
        %if (source eof # 0) %then %return

        select input(source)
        select output(listout)
        %cycle
            readsymbol(ch)
            printsymbol(ch)
            %exit %if (ch = 10) %or (ch < 0)
        %repeat

        %if (ch < 0) %then source eof = 1

        select input(icode)
        select output(objout)
    %end

    !-----------------------------------------------------------
    ! General descriptor and register manipulation routines
    !-----------------------------------------------------------

    !                                                  >> FLOATING <<
    %predicate floating( %record(stackfm)%name v )
        ! check descriptor for floating point quantity
        %true %if (v_type = real)
        %true %if (v_type = lreal)
        %false
    %end

    !                                                  >> ZERO <<
    %predicate zero( %record(stackfm)%name  v )
        ! CHECK DESCRIPTOR FOR (INTEGER) ZERO
        ! JDM JDM sequence of %result = 0 %if is equivalent to %or sequence
        %false %if (v_disp # 0)
        %false %if (v_base # 0)
        %false %if ((v_form # constant) %and (v_form # A V in S))
        %true
    %end

    !                                                  >> CONST <<
    %predicate const( %record(stackfm)%name  v )
        ! CHECK DESCRIPTOR FOR CONSTANT (INTEGER) VALUE
        %false %unless (v_form = constant)
        %false %if (v_type > byte)
        %true
    %end

    ! Find the smaller positive record size of formats A,B
    ! abort if both formats have unknown/zero record sizes
    %integerfn Min Record Size( %record(stackfm)%name A, B )
        %integer N, M

        ! Find the record format tags
        M = A_format
        N = B_format

        ! Find the corresponding record sizes
        ! Ensure we have positive record sizes
        ! We ass-u-me that record sizes are
        ! in the range 0..32767
        M = var(M)_size&16_7FFF %if (M # 0)
        N = var(N)_size&16_7FFF %if (N # 0)

        ! At this point M,N in range 0..32767
        %if (diagnose&4 # 0) %start
            monitor(A, "MIN REC LH ".itos(M,0))
            monitor(B, "MIN REC RH ".itos(N,0))
        %finish

        ! We want the smaller positive value from M,N
        ! Possible cases
        ! (1) M = 0, N = 0   then abort
        ! (2) M = 0, N # 0   then return N
        ! (3) M # 0, N = 0   then return M
        ! (4) M,N # 0, M < N then return M
        ! (5) M,N # 0, N < M then return N

        ! Assume that M has the smaller positive record size
        !             cases 3,4
        ! So we want to see if cases 2,5 are present
        !          case 1,2    case 5
        M = N %if (M = 0) %or (N # 0 %and N < M)

        ! So M is valid for cases 1,2,3,4,5
        ! Now to defend against case 1 (M,N both 0)
        !         cases 2,3,4,5
        %result = M %if M > 0

        ! Arggh! we have case 1
        ! Both formats have unknown/zero record sizes
        Abort("Min Rec Size")
    %end

    !                                                  >> MULSHIFT <<
    %integerfn mulshift( %integer n )
        %integer shift, ref
        ref = 1
        %for shift = 1, 1, 14 %cycle
            ref = ref<<1
            %if (ref >= n) %start
                %if (ref = n) %then %result = shift %else %result = -1
            %finish
        %repeat
        %result = -1
    %end

    !                                                  >> SAME <<
    %predicate same( %record(stackfm)%name  v,w )
        ! Test whether or not V and W describe the same object.
        ! JDM JDM code altered avoid %or to become simple test
        %false %if (v_disp # w_disp)
        %false %if (v_base # w_base)

        %false %if (v_type # w_type)
        %false %if (v_form # w_form)

        %false %if (v_extra # w_extra)
        %false %if (v_scope # w_scope)

        %true
    %end

    ! grab a slab of working store in the local stack
    %integerfn getwork(%integer size)
        %integer cell

        cell = worklist(level)
        %while (cell # 0) %cycle
            %if      (gp tags(cell)_info = size) %c
                %and (gp tags(cell)_flags = 0) %start
                ! suitable candidate?
                ! mark it as in use
                gp tags(cell)_flags = 1
                %result = gp tags(cell)_addr
            %finish
            cell = gp tags(cell)_link
        %repeat

        ! no space available already - make more
        cell = get gp tag

        ! make them all even boundaries
        frame = (frame - size) & (\align)
        gp tags(cell)_addr = frame
        gp tags(cell)_info = size
        gp tags(cell)_link = worklist(level)
        worklist(level) = cell

        ! in use
        gp tags(cell)_flags = 1
        %result = frame
    %end

    ! Return a slab of working store to the free pool
    ! Note that ReturnWork is cautious about what it accepts
    ! - it only takes in items it has previously given out,
    !   so we can call it fairly liberally with any old
    !   rubbish and it will do the right thing
    %routine Return Work( %integer addr )
        %integer cell

        cell = worklist(level)
        %while (cell # 0) %cycle
            %if (gp tags(cell)_addr = addr) %start
                %if (gp tags(cell)_flags = 0) %then abort("Return Work")

                ! mark it as free
                gp tags(cell)_flags = 0
                %return
            %finish
            cell = gp tags(cell)_link
        %repeat

        ! Here, work area was not found - it probably wasn't a work area!
    %end

    ! Check to see if a variable is in a work list assigned block.
    ! Used in string expression compilation to avoid un-necessary copying,
    ! hence only marked true for 256 byte chunks
    %integerfn Is Work( %record(stackfm)%name v )
        %integer cell

        ! JDM JDM replaced long %or test sequence by individual tests
        ! order of tests could be altered for speed
        %result = 0 %if (v_base # EBP)
        %result = 0 %if (v_disp >= 0)
        %result = 0 %if (v_scope # 0)
        %result = 0 %if (v_form # V in S)

        cell = worklist(level);
        %while (cell # 0) %cycle
            %if (gp tags(cell)_addr = v_disp) %start
                %if (gp tags(cell)_flags = 0) %then abort("Is Work")
                %if (gp tags(cell)_info # 256) %then %result = 0
                %result = 1
            %finish
            cell = gp tags(cell)_link
        %repeat

        %result = 0
    %end

    !                                                  >> RELEASE <<
    %routine  release( %integer  reg )
        ! Hazard the value in a register

        ! JDM JDM replaced long %or test sequence by individual tests
        ! order of tests could be altered for speed
        ! check if LOCKED
        %return %if (reg = 0)
        %return %if (reg > fr7)
        %return %if (activity(reg) < 0)

        activity(reg) = activity(reg) - 1
        abort("Release inactive") %if (activity(reg) < 0)
        claimed = claimed - 1
    %end

    !                                                  >> CLAIM <<
    %routine  claim( %integer  reg )
        ! Cherish the value in a register
        abort("Claim bad register") %if (reg > fr7)

        ! JDM JDM replaced long %or test sequence by individual tests
        ! order of tests could be altered for speed

        %return %if (reg = 0)
        %return %if (activity(reg) < 0)

        activity(reg) = activity(reg) + 1
        claimed = claimed + 1
    %end

    !                                                  >> HAZARD <<
    ! Protect any value in register REG by storing in a temporary.
    %routine  hazard( %integer  reg )
        %integer  i, n, t, type

        %routine  mod(%record(stackfm)%name  v)
            %switch  sw(0:a in rec)
            v_base = EBP
            n = n-1
            -> sw(v_form)
sw(a in rec):
            abort("Mod: a in rec")
sw(av in rec):
            abort("Mod: av in rec")
sw(v in rec):
            abort("Mod: v in rec")
sw(constant):
            abort("Mod: constant")
sw(v in s):
            %if (v_disp = 0) %and (v_scope = 0) %start
                v_disp = t
                v_form = a in s
            %else
                !  change (X in S) to (X in REC)
                v_form = v_form + 3
                v_extra = t
            %finish
                                                       -> out1
sw(a in s):
sw(av in s):
            !  change (X in S) to (X in REC)
            v_form = v_form + 3
            v_extra = t
                                                       -> out1
sw(v in r):
            v_form = v in s
            v_disp = t
            v_type = type
                                                       -> out1
out1:
        %end

        n = activity(reg)

        ! NOT IN USE OR CLAIMED?
        %return %if (n <= 0)
        claimed = claimed - n
        activity(reg) = 0
        %if (reg >= fr0) %start
            ! Note that the FPU can only save the top of the stack.
            ! If we need to save something lower down,
            ! we need to pop the things above me first...
            ! and recurse as required
            %if (reg - FR0 >= FPU Stack) %then hazard(reg+1)
            type = lreal
            t = getwork(8)
            dumpfloprm(FSTQ, EBP, t, 0)
        %else
            type = integer
            t = getwork(word size)
            dumpmr(MOV, EBP,t, 0, reg)
        %finish
        %for i = 1, 1, stp %cycle
            mod(stack(i)) %if (stack(i)_base = reg)
        %repeat

        ! USE STILL OUTSTANDING?
        abort("Usage Outstanding") %if (n # 0)
    %end

    !                                                  >> HAZARD ALL <<
    %routine  hazard all
        %integer  j

        %if (claimed # 0) %start
            ! at least one register claimed
            hazard(j) %for j = EAX,1,FR7
        %finish
    %end

    !                                                  >> GP REG <<
    ! Get a general (integer) register
    ! Note that registers EAX, ECX, EDX, EBX are, in order
    ! numbers 1, 2, 3 and 4 (which is convenient)
    %integerfn  gpreg
        %integer  r

        ! look for an empty one
        %for r = EAX,1,EBX %cycle
            %result = r %if (activity(r) = 0)
        %repeat

        ! look for an unlocked one
        %for r = EAX,1,EBX %cycle
            %if (activity(r) > 0) %start
                hazard(r)
                %result = r
            %finish
        %repeat

        abort("Get Reg")
    %end

    !                                                  >> PT REG <<
    %integerfn  pt reg
        ! Get a register we can use as a pointer.
        ! We deliberately rotate around the candidates
        ! - to make re-use more likely
        %constbyteintegerarray  pt pref(0:2) =
            7,   8,   4
        ! ESI, EDI, EBX
        %owninteger next = 0
        %integer  r,j

        ! look for an empty one
        %for j = 1,1,3 %cycle
            r = pt pref(next)
            next = next+1
            next = 0 %if (next = 3)
            %result = r %if (activity(r) = 0)
        %repeat

        ! look for an unlocked one
        %for j = 1,1,3 %cycle
            r = pt pref(j)
            %if (activity(r) > 0) %start
                hazard(r)
                %result = r
            %finish
        %repeat

        abort("Get PT Reg")
    %end

    !                                                  >> GET DISPLAY <<
    ! return the register to use to access display level <n>
    %integerfn getdisplay( %integer l )
        %integer r, lev

        ! get rid of any relocation info
        lev = l&15

        ! global?
        %if (lev = 0) %then %result = l

        ! local?
        %if (lev = level) %then %result = EBP

        ! We now try the 3 pointer register
        ! - they are not contiguously numbered,
        !   which is why this is unrolled!
        %if (displayhint(EBX) = lev) %then %result = EBX
        %if (displayhint(ESI) = lev) %then %result = ESI
        %if (displayhint(EDI) = lev) %then %result = EDI

        r = pt reg

        ! displays are first words in frame
        dumprm(MOV, r, EBP, -(lev * word size), 0 )
        displayhint(r) = lev
        %result = r
    %end

    !                                                  >> SET DOPE VECTOR <<
    ! Plants a dope vector for a 1-D constant bound array (usually
    ! OWN or CONST arrays) in the CONST segment, returns the offset
    ! Note that it also modifies the vlb and vub variables - after
    ! the call, VLB contains the byte offset for the first member
    ! and VUB contains the size to allocate for the array in bytes.
    %integerfn  set dope vector( %integer size, type )
        %integer  entries, dv, descriptor

        ! Make DV _size field to be a size/type/flag format descriptor
        descriptor = (size<<5) ! (type<<1) ! 1

        entries = vub-vlb+1
        dv = getcot4(1, vlb, vub, descriptor)
        vub = entries*size
        vlb = vlb*size
        %result = dv
    %end

    !                                                  >> PERM <<
    ! calls a PERM and adjusts the stack by SPACE words afterwards
    %routine  perm(%integer  n, space)
        ! PERM routines were written in MS C,
        ! as such they preserved SI and DI,
        ! but trash the general purpose registers
        hazard(EAX)
        hazard(ECX)
        hazard(EDX)
        hazard(EBX)
        ! JDM JDM perm routines now implemented as IMP routines
        ! so be more careful and hazard the SI,DI registers as well
        hazard(ESI)
        hazard(EDI)
        dumpextcall(n)
        %if (space # 0) %then dumpri( ADD, ESP, space * word size)
    %end

    !                                                  >> ASSEMBLE <<
    ! AMODE:
    !  -3: initial call
    !  -2: alternate record format
    !  -1: record format
    !   0: begin block
    !   1: procedure
    !   2: %spec
    %routine Assemble( %integer  amode, labs, names )
        %switch c(33:127)
        
        ! General purpose pointer
        %record(varfm)%name v

        ! Var of the current procedure we're compiling
        %record(varfm)%name procvar

        ! Actual parameter ptr, used to copy parms to parm area
        %record(varfm)%name   ap

        ! formal parameter ptr, used to copy parms to parm area
        %record(varfm)%name   fp
        ! General stack pointer
        %record(stackfm)%name lhs

        ! General stack pointers
        %record(stackfm)%name rhs

        ! Used for alternate records to find the largest alternate
        %integer max frame

        ! First descriptor at this level
        %integer first name

        ! Tag used by pass 3 to fix up this level's stack allocation
        %integer staticalloc

        ! Used to jump around routines
        %integer skipproc, lastskip

        ! Event info (mask, entry point, block start)
        %integer events, evep, evfrom

        ! First label at this level
        %integer First label

        ! Previous level's static allocation
        %integer old frame

        %integer j, t
        %integer dv
       
        %routinespec   compile to string(%record(stackfm)%name v)
        ! JDM JDM change name from load()
        %routinespec   loadreg(%record(stackfm)%name v, %integer reg)
        %routinespec   assign(%integer assop)
        %routinespec   array ref(%integer mode)
        %routinespec   Operation(%integer n)
        %routinespec   compare(%record(stackfm)%name l,r)
        %routinespec   test zero(%record(stackfm)%name v)
        %integerfnspec new tag

        ! Actual code for Assemble is down around label NEXT

        !                                              >> DEFINE VAR <<
        %routine  Define Var( %integer tag, %string(255) internal id, %integer tf, size, scope )
            %integer  type, form, format, s, new, round, dimension
            %integer  dv;              ! dope vector offset
            %owninteger  prim no = 0
            %integer flags

            ! JDM JDM remember the core symbol iCode data (name,tf,size,scope)
            ! Needed should an embedded code fragment refer to an IMP variable
            ! The actual variable type, form, size values will be "tweaked" depending
            ! on the target machine
            set symbol data( tag, internal id, tf, size, scope )

            ! JDM JDM debug show the iCode instruction
            %if (diagnose&16 # 0) %start
                ListICode
                spaces(4)
                printstring( itos(tag,0) )
                printsymbol( ',' )
                printsymbol( '"' )
                printstring( internal id )
                printsymbol( '"' )
                printsymbol( ',' )
                printstring( itos(tf,0) )
                printsymbol( ',' )
                printstring( itos(size,0) )
                printsymbol( ',' )
                printstring( itos(scope,0) )
                spaces(4)

                printsymbol( '(' )
                printstring( " " . get own string( scope&7 ) )
                printstring( " " . get type def( (tf>>4), size ) )
                printstring( " " . get external form name( tf&15 ) )
                { See if there are any flags set }

                %if ((scope>>3)&31 # 0) %start
                    { Ok, flags were set so show them }
                    printstring( " [" . get flags string( (scope>>3)&31 ) . "]" )
                %finish

                space
                printsymbol( ')' )

                newline
            %finish
            ! JDM JDM end debug

            ! Now parse the type and form word
            type = (tf>>4)
            form = tf&15

            ! Now analyse the Scope word
            dimension = (scope>>8)&255
            ! JDM JDM debug
            flags = (scope>>3)&31
            otype = scope&7
            spec = flags&1

            ! If this var is really an array,
            !     then remember the array entry type
            ! simple arrays have their bounds defined AFTER the "Define Var"
            ! %switch arrays have their bounds defined BEFORE the "Define Var"
            !     and we would "tag" them as "label" array entry type
            array entry type = get entry type( type, size )

            new = 0
            round = align

            ! Get the var index
            %if (tag = 0) %start
                ! RECORD FORMAT ELEMENT NAME
                parms = parms-1
                abort("Def Var Parms") %if (parms <= names)
                decvar == var(parms)
                decvar = 0
            %else
                abort("Def Var Names (tag=".itos(tag,0)." parms=".itos(parms,0).") Name=".get symbol name(parms)) %if (tag >= parms)
                decvar == var(tag)
                %if (tag > names) %start
                    names = tag
                    new = 1
                    decvar = 0
                %finish
            %finish

            ! Map external type numbers into internal equivalents,
            ! and adjust for short/byte/long things
            %if (type = integer) %and (size # 1) %start
                ! INTEGER
! JDM JDM            type = byte  %and round = 0 %if size = 2
                type = byte %if size = 2
! JDM by default a %short variable is changed to a 4-byte %integer variable
!                type = short %if size = 3
                size = vsize(type)
            %finish %else %if (type = real) %start
                ! REAL
                ! or possibly
                ! LONG REAL
                type = lreal %if (size = 4)
                size = vsize(type)
            %finish %else %if (type = record) %start
                ! record
                format = size
                decvar_format = format
                size = var(format)_size %if (format <= names)
            %finish %else %if (type = string) %start
                ! string
                round = 0
                decvar_size = size
                size = size + 1
            %else
                size = vsize(type)
            %finish
            
            decvar_size = size %if (type # string)
            decvar_type = type
            decvar_form = form

            %if (otype # 0) %start
                ! Set external linkage name if appropriate
                %if (otype >= external) %start
                    %if (length(alias) # 0) %start
                        external id = alias
                    %finish %else %if (otype = system) %start
                        external id = system prefix.internal id
                    %else
                        external id = "_".internal id
                    %finish
                    ! external, system, dynamic?
                    otype = external %if (otype <= dynamic)
                %finish
            %finish
            alias = ""

            ! JDM JDM: Ensure the external displacement is zero
            decvar_extdisp = 0

            %if (switch < form) %and (form < array) %start
                ! PROCEDURE
                ! 1 for normal proc, 2 for spec
                block type = 1 + spec
                %if (otype # 0) %and (spec # 0) %start
                    ! external spec
                    %if (otype = primrt) %start
                        primno = primno + 1
                        decvar_level = 128
                        decvar_disp = prim no
                        %return
                    %finish
                    decvar_disp = externalref(external id)
                    ! JDM JDM: Remember the base external displacement
                    decvar_extdisp = decvar_disp
                    decvar_level = 0
                    decvar_scope = EXT
                    %return
                %finish

                %if (in params = 0) %start
                    ! NOT A PARAMETER
                    potype = otype
                    %if (new # 0) %start
                        ! NEW NAME
                        decvar_disp = new tag
                        ! Procedure ID
                    %finish
                    block name = internal id %if (spec = 0)
                    %return
                %finish

                otype = 0
                size = word size
                data size = word size
                ! procedure parameter

            %else
                ! This is not a procedure declaration
                data size = size
                %if (form # simple) %start
                    Round = Align
                    %if (type = general) %start
                        ! General %name
                        ! FOR LABELS
                        decvar_extra = in params
                        size = word size * 2
                    %finish %else %if (form = array) %or (form = name array) %start
                        ! We will fill in dimensions and allocate space when
                        ! we are told the bounds later
                        size = 0
                        data size = word size %if (form = name array)
                    %finish %else %if (form = array name) %or (form = name array name) %start
                        ! array header
                        decvar_dim = dimension
                        size = word size * 2
                        ! array header
                        round = align
                    %else
                        size = word size;                       ! integer (etc) %name
                    %finish
                %finish
            %finish

            ! Now deal with OWN (or const/extern/etc) data items
            %if (otype # 0) %start
                ! OWN DATA
                %if (otype = con) %start
                    ! CONST INTEGER ETC.
                    ! use actual size for plain strings
                    data size = 0 %if (type = string) %and (form = simple)
                    %if (form = name) %or (form = arrayname) %or (form = namearrayname) %start
                        ! Treat as special later
                        otype = 0
                    %finish
                %else
                    ! OWN, not CONST
                    ! so make it even if needed
                    gfix(round)
                %finish
                ! set globals used by our data collection utilities
                own type = type
                own form = form

                ! %name's are really integers
                own type = integer %and data size = word size %if (form = 2)

                %if (spec = 0) %start
                    %if (form = array) %or (form = name array) %start
                        gfix(align)
                        ! N.B.  changes vlb, vub
                        dv = set dope vector( data size, array entry type )
                        ! We treat OWN and CONST arrays identically - both are in data segment
                        gfix(align)
                        decvar_disp = datatp - vlb;
                        decvar_level = 0
                        decvar_scope = DATA

                        ! save the dope vector pointer here
                        decvar_pbase = dv
                        ! own arrays are always 1-D
                        decvar_dim = 1
                    %finish
                    fill external(DATA, external id) %if (otype = external)
                %else
                    decvar_level = 0
                    decvar_scope = EXT
                    decvar_disp = external ref(external id)
                    ! JDM JDM:
                    ! We have a reference to external data so note the external ref id
                    ! inside the _extdisp field
                    ! _extdisp will NEVER be modified unlike _disp
                    ! Eventually it will be used when generating ABSEXT ibj records
                    ! The difference between _disp and _extdisp represents the offset
                    ! from the location specified by _disp
                    ! offset == _extdisp - _disp
                    decvar_extdisp = decvar_disp
                %finish
            %finish %else %if (form = label) %start
                !%label
                decvar_disp = new tag
            %finish %else %if (form = switch) %start
                size = vub - vlb
                %if (swtp + size > Max Switch) %then abort("Switch Table Full")
                decvar_scope = SWT
                decvar_disp = swtp - vlb
                decvar_extra = set dope vector( data size, switch )
                %for s = swtp, 1, swtp + size %cycle
                    ! should really deal with undefined switch entries
                    swtab(s) = 0
                %repeat
                swtp = swtp + size + 1
            %finish %else %if (form = record format) %start
                %if (in params # 0) %start
                    frame = decvar_size %if (decvar_size > frame)
                %else
                    block type = -1
                    spec = -1
                %finish
            %finish %else %start
                ! Here we've got an ordinary local variable, parameter or record entry
                decvar_level = level
                %if (in params = 0) %start
                    ! local variable
                    frame = (frame - size) & (\round)
                    decvar_disp = frame
                %finish %else %if (block type > 0) %start
                    ! procedure parameters
                    ! parameters are always word aligned
                    frame = (frame + size + align) & (\align)

                    ! offset will be adjusted at iCode '}'
                    decvar_disp = frame
                %finish %else %start
                    ! records
                    frame = (frame + round) & (\round)
                    decvar_disp = frame
                    frame = frame + size

                    ! no base register
                    decvar_level = 0
                %finish
            %finish
        %end
        !    Define Var

        !---------------------------------------------------------------------
        ! Stack manipulation routines
        !---------------------------------------------------------------------
        !                                                      >> POP STACK <<
        ! Pop the top of the stack
        %routine  Pop Stack
            %if (stp = 0) %then abort("Pop")
            monitor(top, "Pop") %if (diagnose&1 # 0)
            stp = stp - 1
            %if (stp # 0) %then top == stack(stp) %else top == null
        %end

        !                                                      >> POP REL <<
        ! Pop the top of the stack, and release its' register
        %routine  pop rel
            release(top_base)
            pop stack
        %end

        %constbyteintegerarray fmap(0:15) =
                 0, V in S,    A in S, pgm label, recordformat,         0,        switch,       0,
        {     void, simple,      name,     label, recordformat,         ?,        switch, routine, }
            V in R, V in S,    V in R,    V in S,       A in S,    V in S,        A in S,       0
        { function,    map, predicate,     array,    arrayname, namearray, namearrayname,       ?  }

        !                                                           >> STACK VAR <<
        ! Push a descriptor on the stack corresponding to Var "var no"
        ! We map the variable form to a stack form, and assign a register
        ! for the base if it is non local.  Finally, we absorb the scope
        ! into the base register.
        %routine  Stack Var(%integer var no)
            %record(varfm)%name  w

            abort("Stack Var Idx") %unless 0 <= var no %and var no <= max vars
            w == var(varno)
            stp = stp + 1
            %if (stp > Max Stack) %then abort("Push V Stack Overflow")
            top == stack(stp)
            top = 0

            ! Translate "level" into "base register" - if it is non local
            ! we flag it by adding 16 to the desired level, which later will
            ! force us to pick up a pointer register
            %if (w_level # 0) %start
                %if (w_level = level) %then top_base = EBP %else top_base = w_level + 16
            %else
                top_base = 0
            %finish

            ! AFORM contains the real original declared form, while
            ! FORM contains the on-the-stack subset of possible forms
            top_aform = w_form
            top_form = fmap(w_form)
            top_dim = w_dim
            top_type = w_type
            top_disp = w_disp
            top_extdisp = w_disp
            top_scope = w_scope
            top_format = w_format
            top_size = w_size
            top_extra = w_extra
            top_pbase = w_pbase

            ! JDM JDM remember variable name via varno and idname
            top_varno = varno
            top_idname = get symbol name( varno )

            monitor(top, "Var stack") %if (diagnose&1 # 0)
        %end

        !                                                      >> LOAD VAR <<
        ! Load a var onto the stack (using StackVar)
        ! JDM JDM this is a wrapper to ensure when reading the iCode data
        ! the iCode data is listed only once.
        ! Why? because Stack Var is used in many locations
        %routine  Load Var(%integer var no)

            ! JDM JDM debug show the iCode instruction
            %if (diagnose&16 # 0) %start
                ListICode
                spaces(4)
                printsymbol( '"' )
                printstring( get symbol name(var no ) )
                printsymbol( '"' )
                newline
            %finish
            ! JDM JDM end debug

            Stack Var( var no )
        %end

        !                                                      >> PUSH COPY <<
        ! Push a duplicate of a stack record onto the stack
        %routine  push copy(%record(stackfm)%name  v)
            stp = stp + 1
            %if (stp > Max Stack) %then abort("Stack Copy")
            top == stack(stp)
            top = v

            monitor(top, "Stack Copy") %if (diagnose&1 # 0)
        %end

        !                                                      >> PUSH CONST <<
        ! Push a constant on the stack
        %routine  push const(%integer  n)
            stp = stp + 1
            %if (stp > Max Stack) %then abort("Stack Const")
            top == stack(stp)
            top = 0
            top_disp = n
            top_extdisp = 0
            top_type = integer
            top_form = constant
            top_idname = itos(n,0)

            monitor(top, "push const") %if (diagnose&1 # 0)
        %end

        ! Load a const onto the stack (using Push Const)       >> PUSH CONST <<
        ! JDM JDM this is a wrapper to ensure when reading the iCode data
        ! the iCode data is listed only once.
        ! Why? because Push Const is used in many locations
        %routine  Load Const(%integer n )

            ! JDM JDM debug show the iCode instruction
            %if (diagnose&16 # 0) %start
                ListICode
                spaces(4)
                printstring( itos(N,0) )
                newline
            %finish
            ! JDM JDM end debug
        
            push const( n )
        %end

        !---------------------------------------------------------------------
        !STRING PROCESSING
        !---------------------------------------------------------------------
        !                                                      >> INPUT STRING VALUE<<
        ! Read a string literal from the iCode stream
        %routine  Input String Value( %string(255) s)
            %integer  i

            ! JDM JDM debug show the iCode instruction
            %if (diagnose&16 # 0) %start
                ListICode
                spaces(4)
                printsymbol( '"' )
                printstring( s )
                printsymbol( '"' )
                newline
            %finish
            ! JDM JDM end debug

            current string(0)= length(s)
            %for i = 1,1,length(s) %cycle
                current string(i) = charno(s,i)
            %repeat

            ! if this is about to be used as a literal, put it straight into
            ! the CONST segment and stack it, otherwise leave it in curr string to see
            ! what comes next and stack a dummy zero
            ! 
            %if (lookaheadiCode # iCodeINIT) %and (lookaheadiCode # iCodeDEF) %start
                otype = con;        ! anonymous %const
                push const( getcots(current string) );
                top_type = string
                top_base = 0;
                top_scope = COT
                top_form = V in S
                top_format = current string(0)+1
            %else
                ! explicit string initialisation coming next
                push const(0)
            %finish
        %end

        %routine Input Real Value( %longreal r )

            ! JDM JDM debug show the iCode instruction
            %if (diagnose&16 # 0) %start
                ListICode
                spaces(4)
                print( r,8 )
                newline
            %finish
            ! JDM JDM end debug

            !  anonymous %const
            ! So insert into/retrieve from the COT table
            otype = con
            push const( getcotdouble(r) )
            top_type = lreal
            top_scope = COT
            top_form = V in S
            top_format = 8

!            %if (r = 0) %then %start
!                push const(0)
!            %else
!                %if (lookaheadiCode # iCodeINIT) %then %start
!                    !  anonymous %const
!                    otype = con
!!                    push const(0)
!                    push const( getcotdouble(r) )
!                    top_type = lreal
!                    top_scope = COT
!                    top_form = V in S
!                    !  N.B. ** %fn + side-effect **
!!                    top_disp = getcotdouble(r)
!!                    top_extdisp = 0
!!                    top_form = V in S
!                %finish
!            %finish

            rvalue = r
        %end

        !-------------------------------------------------------
        !LABEL PROCESSING
        !
        ! Labels fixups are handled by pass 3 - we just plant
        ! numerical labels for code locations, and then jump to or call
        ! those labels.  Pass 3 turns them into real locations.
        ! Unfortunately Pass 3 needs unique label numbers whereas
        ! Pass 1 produces lame local label numbers that can
        ! be reused once they've been defined.  We therefore
        ! maintain an indirect database to map Pass 1 label numbers
        ! into unique tags

        !                                                      >> NEW TAG <<
        ! Get the next consecutive Pass 3 label ID
        %integerfn  new tag
            %owninteger free tag = 999

            free tag = free tag + 1
            %result = free tag
        %end

        !                                                      >> NEW LABEL <<
        ! Get the next available label database index
        %integerfn  New Label
            labs = labs+1
            abort("Labels") %if (labs > Max Labs)
            %result = labs
        %end

        !                                                        >> FIND LABEL<<
        ! return the index in our label table of the Pass 1 label
        %integerfn  Find Label(%integer  label)
            %integer  lp

            lp = labs
            %while (lp # first label) %cycle
                %result = lp %if (labels(lp)_id = label)
                lp = lp-1
            %repeat
            %result = 0
        %end

        !                                                     >> DEFINE LABEL <<
        ! This label is "here"
        %routine  Define Label(%integer  label)
            %integer lp
            %record(labelfm)%name  l

            lp = Find Label(label)
            %if (lp = 0) %start
                ! Not yet been used
                lp = New Label
                l == labels(lp)
                l_id = label
                l_tag = new tag
            %else
                l == labels(lp)
                %if (l_tag&16_8000 # 0) %and (label > 0) %then l_tag = new tag
            %finish

            dump label(l_tag)
            l_tag = l_tag ! 16_8000
            ! You can get here
            uncond jump = 0
        %end
        ! define label

        !                                                          >> JUMP TO <<
        ! A wrapper for conditional jumps to labels that we're going
        ! to map into tags
        %routine  Jump To(%integer  label, op, flag)
            %record(labelfm)%name  l
            %integer  lp

            lp = Find Label(label)
            %if (lp = 0) %start
                lp = New Label
                l == labels(lp)
                l_id = label
                l_tag = new tag
            %else
                l == labels(lp)
                %if (flag # 0) %and (l_tag&16_8000 # 0) %then l_tag = new tag
            %finish

            ! As a side effect, we also set the global J Tag, which is used
            ! in planting Event block information (a bit hacky, but a PSR feature)
            JTag = l_tag & 16_7FFF

            dump jump(op, JTag)

            %if (op = JMP) %then uncond jump = nextcad
        %end
        ! jump to

        %routine Jump Forward( %integer val, test )
            %integer opr

            ! JDM JDM debug show the iCode instruction
            %if (diagnose&16 # 0) %start
                ListICode
                spaces(4)
                printsymbol( 'L' )
                printstring( itos(val,0) )
                newline
            %finish
            ! JDM JDM end debug

            ! FF,TT tests need a value to compare
            ! TT == TRUE (#0)
            ! FF == FALSE (=0)
            %if (Test = FF) %or (Test = TT) %then dumpri(CMP, EAX, 0)
            ! Get the required operator for the test
            ! We may need to amend the choice of operator
            ! depending on the invert/compare unsign "flags"
            opr = TestToOp( test )

            %if (val = 0) %then %start
                %if (last skip # next cad) %then %start
                    skip proc = new tag
                    dumpjump(opr, skip proc)
                %finish
            %else
                ! Check if we need to reverse the test
                ! So, re-choose the operator
                %if (invert # 0) %then Test = Reverse( Test )
                invert = 0;

                ! convert the operators to unsigned versions if needed
                %if (compare unsign # 0) %then opr = TestToUnsignedOp( Test ) %else opr = TestToOp( Test )
                compare unsign = 0

                jump to(val, opr, 1)
            %finish
        %end;               ! Jump Forward

        %routine Jump Backward( %integer val )

            ! JDM JDM debug show the iCode instruction
            %if (diagnose&16 # 0) %start
                ListICode
                spaces(4)
                printsymbol( 'L' )
                printstring( itos(val,0) )
                newline
            %finish
            ! JDM JDM end debug

            jump to(val, JMP, 0);
        %end

        !-------------------------------------------------------
        ! Stack variable transformations
        !-------------------------------------------------------
        !                                           >> REDUCE <<
        ! Convert a variable which is addressed in a Rec into a simple variable
        ! by loading the indirect value into a register and changing the form
        %routine  reduce(%record(stackfm)%name  v)
            %integer  type, form, disp, scope, extdisp
   
            form = v_form - 3;         ! X in REC => X in S
            type = v_type
            disp = v_disp
            extdisp = v_extdisp
            ! Here's a trick - we've got two displacements, DISP and EXTRA, but only
            ! one SCOPE hint.  Which does it belong to?  If the REC form came from
            ! a HAZARD then the scope belongs to the DISP, but for all other cases
            ! the scope belongs to the EXTRA.  If we got here through HAZARD then
            ! the BASE will be EBP - for all other cases it will be either a different
            ! register, or zero.
            %if (v_base = EBP) %start
                scope = v_scope
                v_scope = 0
            %else
                scope = 0
            %finish
            v_disp = v_extra
            v_type = integer
            v_form = V in S

            loadreg(v, anyp)

            v_type = type
            v_form = form
            v_disp = disp
            v_extdisp = extdisp
            v_scope = scope
        %end

        !                                              >> AMAP <<
        ! convert V into a descriptor for the address of V
        %routine  amap(%record(stackfm)%name  v)
            %integer f
            %constintegerarray  addr map(0:15) =
            {    0,        1,  2,  3,       4,   5,               6,                   7, }
                -1,       -2, -3, -4, AV in S,  -5,          V in S,           AV in REC,

            {    8,        9, 10, 11,      12,  13,              14,                  15  }
                -6, V in REC, -7, -8,      -9, -10, {PGM LABEL} -11, {record format} -12

            ! ABD - should be code here to deal with ADDR(pgm label)

            f = addr map(v_form)
            %if (f < 0) %start
                monitor(v, "AMAP target")
                abort("AMAP")
            %finish

            ! Try to simplify some forms...
            %if (v_disp = 0) %and (v_scope = 0) %start
                %if (f = A V in S) %start
                    %if (v_base = 0) %then f = constant %else f = V in R
                %finish %else %if (f = V in REC) %or (f = A V in REC) %start
                    ! eliminate redundant LOAD
                    %if (f = V in REC) %then f = A in S %else f = V in S
                    v_disp = v_extra
                %finish
            %finish
            v_type = integer
            v_form = f
        %end

        !                                              >> VMAP <<
        ! The inverse of AMAP:  i.e. vmap(amap(x)) => x
        %routine  vmap(%record(stackfm)%name  v)
            %integer  f, t
            %constintegerarray  var map(0:8) =
            {      0,      1,  2,  3,      4,      5,  6,        7,        8 }
              V in S, V in S, -1, -2, A in S, V in S, -3, A in REC, V in REC

            %if (v_form = A in S) %or (v_form = A in REC) %start
                t = v_type
                amap(v)
                loadreg(v,anyp)
                v_type = t
                v_form = V in S
            %finish
            f = var map(v_form)
            v_form = f
            abort("VMap") %if (f < 0)
        %end
        !  v map

        !                                              >> ADDRESS <<
        ! convert V into a form in which it is directly addressable
        ! that means either V in R, V in S or Constant
        %routine  address(%record(stackfm)%name  v)
            %integer  type, form
   
            monitor(v, "ADDRESS") %if (diagnose&2 # 0)

            form = v_form
            type = v_type
            %if (form >= V in REC) %start
                reduce(v)
                form = v_form
            %finish

            ! Now pick up a base register if we needed one...
            %if (v_base > 16) %start
                v_base = get display(v_base - 16)
                claim(v_base)
            %finish

            %return %if (form = V in R) %or (form = constant)

            %if (form = A V in S) %start
                %if (v_base = 0) %start
                    v_form = constant
                %else
                    %if (v_disp = 0) %and (v_scope = 0) %start
                        v_form = V in R
                    %else
                        loadreg(v, any)
                    %finish
                %finish
                %return
            %finish

            %return %if (form = V in S)
   
            %if (form = A in S) %start
                v_form = V in S
                v_type = integer
                loadreg(v,anyp)
                v_type = type
                v_form = V in S
                v_disp = 0
            %finish
        %end
        ! address

        !                                              >> LOAD REG <<
        ! Load variable V into register R
        ! Along the way any register the variable owned is released, and
        ! the new register is claimed.
        %routine LoadReg(%record(stackfm)%name v, %integer r)
            %switch f(0:9)
            %integer ptr, op

            monitor(v, "LOAD") %if (diagnose&2 # 0)

            %if (r = anyf) %start
                ! Equivalents for real numbers...
                ! because there's very little clever we can do, we first simplify somewhat...
                Address(v)
                ! Now it's either Constant, V in R or V in S - we now turn them
                ! all into V in S - the only thing we can load
                ! Start with one we have no instructions for, and promote it to
                ! something we know how to handle...
                %if (v_type = byte) %then loadreg(v, any)
                %if (v_form = V in R) %start
                    %return %if (v_base >= FR0)
                    ! This must be an integer in a CPU register - we need to store it
                    ! before we can use it
                    v_disp = getwork(word size)
                    dumpmr(MOV, EBP, v_disp, v_extdisp, v_base)
                    release(v_base)
                    v_base = EBP
                    v_scope = 0
                    v_form = V in S
                    ! Now it looks like an integer V in S
                %finish

                %if (v_form = constant) %start
                    ! This is an integer constant
                    %if (v_disp = 0) %start
                        ! We have a special instruction for zero
                        r = FR0 + FPU Stack
                        dumpflopspec(FLDZ)
                        v_base = r
                        claim(r)
                        v_disp = 0
                        v_form = V in R
                        v_type = real
                        %return
                    %finish
                    ! Otherwise, we need it in store
                    v_disp = getcotw(v_disp)
                    v_form = V in S
                    v_base = 0
                    v_scope = COT
                %finish

                ! Now everything that's left is a V in S
                %if (v_type = integer) %start
                    op = FILD
                %else
                    %if (v_type = real) %start
                        op = FLDD
                    %else
                        op = FLDQ
                    %finish
                %finish

                ! register is going to be the top of stack
                r = FR0 + FPU Stack

                dumpfloprm(op, v_base!v_scope, v_disp, v_extdisp )
                release(v_base)
                v_base = r
                claim(r)
                v_disp = 0
                v_form = V in R
                v_type = real
                %return
            %finish

            ! If the request is one of the variations on "any" then we need
            ! to first allocate a target register.  First, we make a local
            ! adjustment because we can't load bytes into "any" register,
            ! only into the GP registers...
            %if (v_type = byte) %start
                %if (r = any) %then r = anyg
                ! What's more, there is only one register that is both a pointer
                ! and a legal byte destination
                %if (r = anyp) %then r = EBX
            %finish

            ! We also map the virtual display into a real register if we
            ! need to.  Also, it is possible that an in-store form may
            ! be derived from a non-pointer register, so we fix that too.
            %if (v_base >= AL) %then %start
                { then map to a 32-bit reg in range EAX..EDI }
                v_base = get display(EAX + v_base - AL)
                claim(v_base)
            %finish

            ! Now go ahead and allocate a register
            %if (r = any) %then %start
                ! If we've got a base,
                ! it's not in use by anyone else,
                ! and isn't a display register,
                ! then use it
                %if (v_base # 0) %and (activity(v_base) = 1) %and (displayhint(v_base) = 0) %start
                    r = v_base
                %finish %else %start
                    r = gp reg
                %finish
            %finish %else %if (r = anyg) %then %start
                %if (0 < v_base <= EBX) %and (activity(v_base) = 1) %start
                    r = v_base
                %finish %else %start
                    r = gp reg
                %finish
            %finish %else %if (r = anyp) %then %start
                %if (activity(v_base) = 1) %and ((v_base = EBX) %or (v_base = ESI) %or (v_base = EDI)) %then %start
                    r = v_base
                %finish %else %start
                    r = pt reg
                %finish
            %finish %else %if (v_base = r) %start
                %if (activity(r) > 1) %start
                    ! protect other uses
                    release(r)

                    ! Hide my ownership for the moment
                    v_base = 0

                    ! Zap everybody else
                    hazard(r)

                    ! Get it back
                    claim(r)
                    v_base = r
                %finish
            %finish %else %start
                hazard(r)
            %finish
            -> f(v_form)

f(V in REC):
            reduce(v)
            ->f(v_form)

f(AV in REC):
            reduce(v)
            ->f(v_form)

f(A in REC):
            reduce(v)
            ->f(v_form)

f(AV in R):
            Abort("Unexpected Stack Form")

f(A in R):
            Abort("Unexpected Stack Form")

f(constant):
            %if (v_disp = 0) %and (v_scope = 0) %start
                dumprr(XOR, r, r)
            %else
                dumprioffset(MOV, r, v_scope, v_disp, v_extdisp )
            %finish
            v_base = r
            v_disp = 0
            v_scope = 0
            v_form = V in R
            claim(r)
            %return

f(V in R):
            %return %if (v_base = r)
            dumprr(MOV, r, v_base)
            release(v_base)
            v_base = r
            v_disp = 0
            v_scope = 0
            v_form = V in R
            claim(r)
            %return

f(A in S):
            ! is the register a pointer?
            %if (r = EBX) %or (r = ESI) %or (r = EDI) %start
                ptr = r
            %finish %else %start
                ptr = pt reg
            %finish
            dumprm(MOV, ptr, v_base!v_scope, v_disp, v_extdisp )
            release(v_base)
            claim(ptr)
            v_base = ptr
            v_disp = 0
            v_scope = 0
            %if (v_type = integer) %start
                dumprm(MOV, r, v_base!v_scope, v_disp, v_extdisp )
            %finish %else %if (v_type = short) %start
                ! JDM JDM temporarily pretend it's a 32-bit integer
                dumprm(MOVSX, r, v_base!v_scope, v_disp, v_extdisp )
            %finish %else %if (v_type = byte) %start
                ! watch out for register re-use here...

                ! clear it, but only if it isn't needed
                %if (r # v_base) %then dumprr(XOR, r, r)
                ! Convert the register to be in the AL..BH range
                dumprm8(MOV, AL + r - EAX, v_base!v_scope, v_disp, v_extdisp )

                ! otherwise a more expensive clear later
                %if (r = v_base) %then dumpri(AND, r, 255)
                v_type = integer
            %finish %else %start
                ! reals
                abort("Load Real")
            %finish
            release(v_base)
            v_base = r
            v_disp = 0
            v_scope = 0
            v_form = V in R
            claim(r)
            %return

f(V in S):
            %if (v_type = integer) %start
                dumprm(MOV, r, v_base!v_scope, v_disp, v_extdisp )
            %finish %else %if (v_type = short) %start
                ! JDM JDM temporarily pretend it's a 32-bit integer
                dumprm(MOVSX, r, v_base!v_scope, v_disp, v_extdisp )
            %finish %else %if (v_type = byte) %start
                ! watch out for register re-use here...

                ! clear it, but only if it isn't needed
                %if (r # v_base) %then dumprr(XOR, r, r)
                ! Convert the register to be in the AL..BH range
                dumprm8(MOV, AL + r - EAX, v_base!v_scope, v_disp, v_extdisp )

                ! otherwise a more expensive clear later
                %if (r = v_base) %then dumpri(AND, r, 255)
                v_type = integer
            %finish %else %start
                ! reals
                abort("Load Real")
            %finish
            release(v_base)
            v_base = r
            v_disp = 0
            v_scope = 0
            v_form = V in R
            claim(r)
            %return

f(A V in S):
            %if (v_base # 0) %start
                dumprm(LEA, r, v_base!v_scope, v_disp, v_extdisp )
                release(v_base)
                v_type = integer
            %finish %else %if (v_disp = 0) %and (v_scope = 0) %start
                ! else
                dumprr(XOR, r, r)
            %finish %else %start
                dumprioffset(MOV, r, v_scope, v_disp, v_extdisp )
            %finish
            v_base = r
            v_disp = 0
            v_scope = 0
            v_form = V in R
            claim(r)
            %return
        %end
        ! LOAD REG

        !                                              >> OPERATION <<
        ! perform the operation OP on the top two elements of the stack.
        !   (single element for unary operators)
        %routine  Operation(%integer op)
            %record(stackfm)%name  lhs, rhs
            %integer assign pending, work, value, s
            %switch oper(1:17), roper(1:17), fold(1:17)
            %constintegerarray opmap(1:17) = 
            ADD, SUB, IMUL, IDIV,  0,  AND, OR, XOR, SHL, SHR, IDIV,   0,    0,   0,  NOT, NEG,   0

            %constintegerarray flopmap(1:17) = 
            FADD, FSUB, FMUL, FDIV, 0, 0, 0, 0, 0, 0, 0,   0,   0,    FDIV, 0, FCHS, FABS

            %constintegerarray indec(-1:1) = DEC, 0, INC; ! decrement, and increment opcodes

            %routine swap
                %record(stackfm) temp
                temp = lhs
                lhs = rhs
                rhs = temp
            %end

            assign pending = 0
            rhs == top
            %if (op < Unaries) %then %start
                lhs == stack(stp-1)
                %if (lhs_type = real) %or (lhs_type = lreal) %or (op >= REXPx) %then ->reals
            %finish

            %if (rhs_type = real) %or (rhs_type = lreal) %then ->reals

            %if (rhs_form = constant) %and ((op >= Unaries) %or (lhs_form = constant)) %then ->fold(op)

            ! now look for optimisations for x = x <op> whatever
            %if (lookaheadiCode = iCodeASSVAL) %or (lookaheadiCode = iCodeJAM) %start
                ! the next task is an assignment
                %if (op >= Unaries) %start
                    %if same(top, stack(stp-1)) %then assign pending = 1
                %finish %else %start
                    %if same(lhs, stack(stp-2)) %then assign pending = 1
                %finish
            %finish

            ->oper(op)
oper(NOTx):
oper(NEGx):
            ! we optimise for e.g. fred = -fred as one instruction
            %if (assign pending # 0) %then %start
                next iCode
                address(rhs)
                %if (rhs_type = byte) %start
                    dumpum8(opmap(op), rhs_base!rhs_scope, rhs_disp, rhs_extdisp )
                %finish %else %if (rhs_type = short) %start
                    dumpum(opmap(op), rhs_base!rhs_scope, rhs_disp, rhs_extdisp )
                %finish %else %start
                    dumpum(opmap(op), rhs_base!rhs_scope, rhs_disp, rhs_extdisp )
                %finish

                ! RHS
                pop rel
                ! Assignment destination
                pop rel

                %return
            %finish
            loadreg(rhs, any)
            dumpur(opmap(op), rhs_base)
            %return

            ! 8086 has no "abs" instructions, so we do a test and jump
oper(ABSx):
            loadreg(rhs, any)
            dumpri(CMP, rhs_base, 0)
            work = new tag
            dumpjump(JGE, work)
            dumpur(NEG, rhs_base)
            dumplabel(work)
            %return

oper(ADDX):
            %if (lhs_form = constant) %then swap
            ! and fall through to minus
oper(SUBx):
            ! First look for fred = fred + <whatever>
            ! We can only safely do this for bytes if we're jamming or ignoring overflow
            %if (assign pending # 0) %and %c
                ((lhs_type = integer) %or ((control & check capacity) = 0) %or (lookaheadiCode = iCodeJAM)) %then %start

                ! we will do the assignment ourselves
                next iCode

                ! make LHS accessible
                address(lhs)
                %if (rhs_form = constant) %then %start
                    value = rhs_disp
                    %if (value # 0) %start
                        %if (op = SUBx) %then value = -value
                        ! look for increment or decrement instructions
                        %if (-2 < value < 2) %then %start
                            %if (lhs_type = byte) %start
                                dumpum8(indec(value), lhs_base!lhs_scope, lhs_disp, lhs_extdisp )
                            %finish %else %if (lhs_type = short) %start
                                dumpum(indec(value), lhs_base!lhs_scope, lhs_disp, lhs_extdisp )
                            %finish %else %start
                                dumpum(indec(value), lhs_base!lhs_scope, lhs_disp, lhs_extdisp )
                            %finish
                        %finish %else %start
                            %if (lhs_type = byte) %start
                                dumpmi8(opmap(op), lhs_base!lhs_scope, lhs_disp, lhs_extdisp, rhs_disp)
                            %finish %else %if (lhs_type = short) %start
                                dumpmi(opmap(op), lhs_base!lhs_scope, lhs_disp, lhs_extdisp, rhs_disp)
                            %finish %else %start
                                dumpmi(opmap(op), lhs_base!lhs_scope, lhs_disp, lhs_extdisp, rhs_disp)
                            %finish
                        %finish
                    %finish
                %finish %else %start
                    ! RHS not a constant
                    loadreg(rhs, any)
                    %if (lhs_type = byte) %start
                        ! Convert "rhs_base" to reg in range AL .. BL
                        dumpmr8(opmap(op), lhs_base!lhs_scope, lhs_disp, lhs_extdisp, AL + rhs_base - EAX)
                    %finish %else %if (lhs_type = short) %and (control&4 # 0) %start
                        dumprr(opmap(op), EAX, rhs_base)
                        ! JDM JDM
                        ! Will the result fit into a %short (-32768..32767)?
                        ! So, use impcheck1??
                        ! PUSH rhs_base
                        dumpur(PUSH, EAX)
                        ! CALL impcheck1 and tidy up stack
                        perm(check1, 1)
                        ! now store the validated %short value
                        dumpmr(MOV, lhs_base!lhs_scope, lhs_disp, lhs_extdisp, EAX)
                    %finish %else %start
                        dumpmr(opmap(op), lhs_base!lhs_scope, lhs_disp, lhs_extdisp, rhs_base)
                    %finish
                %finish

                ! RHS
                pop rel
                ! LHS
                pop rel
                ! Assignment destination
                pop rel

                %return
            %finish

            ! So, there is no assign pending        
            %if (rhs_form = constant) %then %start
                value = rhs_disp
                %if (op = SUBx) %then value = -value
                ! If it is already an address, do the math on the address offset
                %if (lhs_form = AV in S) %or (lhs_form = AV in Rec) %start
                    lhs_disp = lhs_disp + value
                %finish %else %start
                    loadreg(lhs, any)
                    ! We don't particularly try for it, but if we ended up with a pointer
                    ! register, we might as well convert this to use the address form...
                    %if (lhs_base = EBX) %start
                        ! EBX is the only GP reg that's also a pointer
                        lhs_form = AV in S
                        lhs_disp = value
                    %finish %else %start
                        ! otherwise, don't bother deferring the operation
                        ! look for increment or decrement instructions
                        %if (-2 < value < 2) %then %start
                            %if (value # 0) %then dumpur(indec(value), lhs_base)
                        %finish %else %start
                            dumpri(opmap(op), lhs_base, rhs_disp)
                        %finish
                    %finish
                %finish
            %finish %else %start
                ! not a constant
                ! commutative?, so flip it
                %if (op = ADDx) %and (rhs_form = V in R) %then swap
                loadreg(lhs, any)
                %if (rhs_type = byte) %start
                    loadreg(rhs, any)
                %finish %else %if (rhs_type = short) %start
                    loadreg(rhs, any)
                %finish %else %start
                    address(rhs)
                %finish
                %if (lhs_type = short) %and (control&4 # 0) %start
                    ! JDM JDM
                    ! Will the result fit into a %short (-32768..32767)?
                    ! So, use impcheck1??
                    dumprv(opmap(op), lhs_base, rhs)
                    ! PUSH calculated value
                    dumpur(PUSH, lhs_base)
                    release(lhs_base)
                    ! CALL impcheck1 and tidy up stack
                    perm( check1, 1)
                    lhs_base = EAX
                    claim(EAX)
                    lhs_form = V in R
                %finish %else %start
                    dumprv(opmap(op), lhs_base, rhs)
                %finish
            %finish

            ! the RHS
            pop rel

            %return
oper(ANDx):
oper(ORx):
oper(XORx):
            !  Logical ops are a subset of ADD - similar behaviour, but no inc/dec/addr short forms
            %if lhs_form = constant %then swap
            ! First look for fred = fred <op> <whatever>
            %if (assign pending # 0) %then %start
                ! we will do the assignment ourselves
                next iCode

                ! make LHS accessible
                address(lhs)
                %if (rhs_form = constant) %then %start
                    value = rhs_disp
                    %if (lhs_type = byte) %start
                        ! JDM JDM Remember rhs_disp contains a signed 32-bit integer constant value
                        ! So the signed 32-bit integer range allowed for a %byte (== 8-bit unsigned integer)
                        ! has bit range 16_00000000:16_000000FF
                        ! These then correspond to 32-bit integer values 0:255
                        ! So an 8-bit byte must be in the 32-bit integer range 0:255
                        ! Thus check for values in the 32-bit integer range 0:255

!                        warn(8) %if (rhs_disp&(\255) # 0)
!                        warn(8) %unless (0 <= rhs_disp <= 255)
                        warn(8) %unless (-256 <= rhs_disp <= 255)

                        ! Do an immediate to memory store on the byte value in rhs_disp
                        dumpmi8(opmap(op), lhs_base!lhs_scope, lhs_disp, lhs_extdisp, rhs_disp&255)
                    %finish %else %if (lhs_type = short) %start
                        ! JDM JDM Remember rhs_disp contains a signed 32-bit integer constant value
                        ! So the signed 32-bit integer range allowed for a %short (== 16-bit signed integer)
                        ! has bit range 16_00000000:16_00008000 or 16_FFFF8000:16_FFFFFFFF
                        ! noting that 16_00008000 will be -32768 (when sign-extended to be 16_FFFF8000)
                        ! These then correspond to 32-bit integer values 0:32768 or -32768:-1
                        ! So a 16-bit integer must be in the 32-bit integer range -32768:-1 or 0:32768
                        ! Thus check for values in the 32-bit integer range -32768:32768

!                        warn(9) %if (rhs_disp&(\16_ffff) # 0)
                        warn(9) %unless (-32768 <= rhs_disp <= 32768)

                        ! JDM JDM We are doing an immediate value to memory
                        ! This allows 8-bit byte or 32-bit integer operation
                        dumpmi(opmap(op), lhs_base!lhs_scope, lhs_disp, lhs_extdisp, rhs_disp)
                    %finish %else %start
                        dumpmi(opmap(op), lhs_base!lhs_scope, lhs_disp, lhs_extdisp, rhs_disp)
                    %finish
                %finish %else %start
                    ! RHS not a constant
                    loadreg(rhs, any)
                    %if (lhs_type = byte) %start
                        ! Convert "rhs_base" to reg in range AL .. BL
                        dumpmr8(opmap(op), lhs_base!lhs_scope, lhs_disp, lhs_extdisp, AL + rhs_base - EAX)
                    %finish %else %if (lhs_type = short) %start
                        ! now store the un-validated %short value
                        dumpmr(opmap(op), lhs_base!lhs_scope, lhs_disp, lhs_extdisp, rhs_base)
                    %finish %else %start
                        dumpmr(opmap(op), lhs_base!lhs_scope, lhs_disp, lhs_extdisp, rhs_base)
                    %finish
                %finish

                ! RHS
                pop rel
                ! LHS
                pop rel
                ! Assignment destination
                pop rel

                %return
            %finish

            ! So, there is no assign pending        
            %if (rhs_form = constant) %then %start
                value = rhs_disp
                loadreg(lhs, any)
                dumpri(opmap(op), lhs_base, value)
            %finish %else %start
                ! not a constant
                ! all these are commutative, so flip it to make it easier
                %if (rhs_form = V in R) %then swap
                loadreg(lhs, any)
                %if (rhs_type = byte) %and (op = ANDx) %start
                    ! AND needs all the bits to make sense
                    ! NB Load changes type to Integer
                    loadreg(rhs, any)
                %finish %else %start
                    address(rhs)
                %finish
                %if (rhs_type = byte) %start
                    ! must be V in S - everything else would be Integer
                    ! Convert the register to be in the AL..BH range
                    dumprm8(opmap(op), AL + lhs_base -EAX, rhs_scope!rhs_base, rhs_disp, rhs_extdisp )
                %finish %else %start
                    dumprv(opmap(op), lhs_base, rhs)
                %finish
            %finish

            ! the RHS
            pop rel

            %return

oper(MULx):
            %if (lhs_form = constant) %or (rhs_base = EAX) %then swap
            %if (rhs_form = constant) %then %start
                value = rhs_disp
                %if (value = 0) %then %start
                    ! mul by zero is zero
                    release(lhs_base)
                    lhs = rhs
                    pop stack
                    %return
                %finish
                %if (value = 1) %then %start
                    ! mul by 1 is the identity
                    pop stack
                    %return
                %finish

                ! find a shift factor
                s = mulshift(value)
                %if (s > 0) %then %start
                    rhs_disp = s
                    op = LSHx
                    -> shift it
                %finish
                ! 8086 multiply instruction doesn't have an immediate operand form
                ! so we use an entry in the constant table...
                rhs_base = 0
                rhs_scope = COT
                rhs_disp = getcotw(value)
                rhs_form = V in S
                ! and fall through to the not-a-constant path
            %finish
do mul:
            loadreg(lhs, EAX)
            address(rhs)
            hazard(EDX)
            %if (rhs_form = V in R) %start
                dumpur(IMUL, rhs_base)
            %finish %else %start
                dumpum(IMUL, rhs_base!rhs_scope, rhs_disp, rhs_extdisp )
            %finish

            %if (lhs_type = short) %and (control&4 # 0) %start
                ! JDM JDM
                ! Will the result fit into a %short (-32768..32767)?
                ! So, use impcheck1??
                ! PUSH calculated value
                dumpur(PUSH, EAX)
                ! CALL impcheck1 and tidy up stack
                perm( check1, 1)
            %finish

            pop rel
            %return
oper(DIVx):
oper(REMx):
            loadreg(lhs, EAX)
            address(rhs)
            hazard(EDX)
            dumpsimple(CWD)
            ! Plain 80386 Divide instruction also has no immediate operand form, so
            ! we move constants to the COT
            %if (rhs_form = constant) %start
                %if (rhs_disp = 0) %then warn(1)
                rhs_base = 0
                rhs_scope = COT
                rhs_disp = getcotw(rhs_disp)
                rhs_form = V in S
            %finish
            %if (rhs_form = V in R) %start
                ! Defend against divide-by-zero
                dumpur(IDIV, rhs_base)
            %finish %else %start
                ! Defend against divide-by-zero
                dumpum(IDIV, rhs_base!rhs_scope, rhs_disp, rhs_extdisp )
            %finish

            pop rel
            %if (op = DIVx) %then %start
                ! we want the quotient value
                lhs_base = EAX
            %finish %else %start
                ! we want the remainder value
                lhs_base = EDX
                release(EAX)
                claim(EDX)
            %finish

            ! At this point
            ! (1) Quotient in %EAX
            ! (2) Remainder in %EDX
            %if (lhs_type = short) %and (control&4 # 0) %start
                ! JDM JDM use check to be inserted (for %short only)

                ! Test the Quotient/Remainder value
                %if (op = DIVx) %then %start
                    ! we want the quotient value
                    dumpur(PUSH, EAX)
                %finish %else %start
                    ! we want the remainder value
                    lhs_base = EDX
                    dumpur(PUSH, EDX)
                %finish

                ! JDM JDM
                ! Will the result fit into a %short (-32768..32767)?
                ! So, use impcheck1??
                ! CALL impcheck1 and tidy up stack
                ! %result is in %EAX
                perm( check1, 1)

                ! move the validated Quotient/Remainder value into %EAX
                %if (op = DIVx) %then %start
                    ! we want the quotient value
                    dumprr(MOV, EAX, EAX)
                %finish %else %start
                    ! we want the remainder value
                    dumprr(MOV, EDX, EAX)
                %finish
            %finish

            %return
oper(LSHx):
oper(RSHx):
shift it:
            %if (assign pending # 0) %and %c
                ((op = RSHx) %or (lhs_type = integer) %or (control&check capacity = 0) %or (lookaheadiCode = iCodeJAM)) %then %start
                ! we will do the assignment ourselves
                next iCode

                ! make LHS accessible
                address(lhs)
                %if (rhs_form = constant) %start
                    warn(6) %unless (0 <= rhs_disp <= 31)
                    %if (rhs_disp # 0) %start
                        ! shift by zero is a no-op
                        %if (lhs_type = byte) %start
                            dumpmi8(opmap(op), lhs_base!lhs_scope, lhs_disp, lhs_extdisp, rhs_disp)
                        %finish %else %start
                            dumpmi(opmap(op), lhs_base!lhs_scope, lhs_disp, lhs_extdisp, rhs_disp)
                        %finish
                    %finish
                %finish %else %start
                    ! RHS not a constant
                    ! Since the shift instruction only uses the bottom 5 bits of the
                    ! value in ECX, the value is "byte safe".  Rather than do a full
                    ! "loadreg(rhs,ECX)" we therefore fiddle about and do it the hard way
                    ! to save redundant coding
                    %if (rhs_type = byte) %start
                        hazard(ECX)
                        address(rhs)
                        dumprm8(MOV, CL, rhs_scope!rhs_base, rhs_disp, rhs_extdisp )
                    %finish %else %start
                        loadreg(rhs,ECX)
                    %finish
                    %if (lhs_type = byte) %start
                        dumpmr8(opmap(op), lhs_base!lhs_scope, lhs_disp, lhs_extdisp, CL)
                    %finish %else %if (lhs_type = short) %start
                        dumpmr(opmap(op), lhs_base!lhs_scope, lhs_disp, lhs_extdisp, ECX)
                    %finish %else %start
                        dumpmr(opmap(op), lhs_base!lhs_scope, lhs_disp, lhs_extdisp, ECX)
                    %finish
                %finish

                ! RHS
                pop rel
                ! LHS
                pop rel
                ! Assignment destination
                pop rel

                %return
            %finish

            ! deal with constant shifts first...
            %if (rhs_form = constant) %then %start
                value = rhs_disp
                warn(6) %unless (0 <= value <= 31)
                %if (value # 0) %start
                    loadreg(lhs, any)
                    dumpri(opmap(op), lhs_base, value)
                %finish
            %finish %else %start
                ! RHS variable
                ! Since the shift instruction only uses the bottom 4 bits of the
                ! value in ECX, the value is "byte safe".  Rather than do a full
                ! "loadreg(rhs,ECX)" we therefore fiddle about and do it the hard way
                ! to save redundant coding
                %if (rhs_type = byte) %start
                    hazard(ECX)
                    address(rhs)
                    dumprm8(MOV, CL, rhs_scope!rhs_base, rhs_disp, rhs_extdisp )
                    release(rhs_base)
                    rhs_base = ECX
                    claim(ECX)
                %finish %else %if (rhs_type = short) %start
                    loadreg(rhs,ECX)
                %finish %else %start
                    loadreg(rhs,ECX)
                %finish
                loadreg(lhs, any)
                dumprr(opmap(op), lhs_base, ECX);
            %finish

            pop rel

            %return
oper(EXPx):
            %if (rhs_form = constant) %then %start
                %if (rhs_disp = 0) %start
                    pop rel
                    pop rel
                    push const(1)
                    %return
                %finish
                %if (rhs_disp = 1) %then %start
                    pop rel
                    %return
                %finish
                %if (rhs_disp = 2) %then %start
                    rhs = lhs
                    claim(rhs_base)
                    ->do mul
                %finish
            %finish

            loadreg(rhs, any)
            dumpur(PUSH, rhs_base)
            pop rel
            loadreg(lhs, any)
            dumpur(PUSH, lhs_base)
            release(lhs_base)
            perm(iexp, 2)

            %if (lhs_type = short) %and (control&4 # 0) %start
                ! JDM JDM use check to be inserted (for %short only)
                ! PUSH calculated value
                dumpur(PUSH, EAX)
                ! Do we get a value in the %short range -32768..32767)?
                ! so, CALL impcheck1 and tidy up stack
                perm( check1, 1)
            %finish

            lhs_base = EAX
            claim(EAX)
            lhs_form = V in R

            %return
oper(REXPx):
oper(RDIVx):
            abort("Oper unexpected op")

            !-----------------------------------------------
            ! Fold constant expressions at compile time
fold(NEGx):
            value = -rhs_disp; -> set unary
fold(NOTx):
            value = \rhs_disp; -> set unary
fold(ABSx):
            value = rhs_disp; %if (value < 0) %then value = -value; -> set value
fold(ADDx):
            value = lhs_disp + rhs_disp; -> set value
fold(SUBx):
            value = lhs_disp - rhs_disp; -> set value
fold(ORx):
            value = lhs_disp ! rhs_disp; -> set value
fold(ANDx):
            value = lhs_disp & rhs_disp; -> set value
fold(XORx):
            value = lhs_disp !! rhs_disp; -> set value
fold(LSHx):
            value = lhs_disp << rhs_disp; -> set value
fold(MULx):
            value = lhs_disp * rhs_disp; -> set value
fold(RSHx):
            value = lhs_disp >> rhs_disp; -> set value
fold(EXPx):
            %if (rhs_disp < 0) %then abort("Fold -ve Exp")
            value = 1
            %for op=1, 1, rhs_disp %cycle
                value = value * lhs_disp
            %repeat
            -> set value
fold(REMx):
fold(DIVx):
            value = rhs_disp;
            warn(1) %and value = 1 %if (value = 0)
            value = lhs_disp // value
            %if (op = DIVx) %then -> set value
            value = lhs_disp - (rhs_disp * value)
            -> set value
fold(REXPx):
            abort("Fold REXPx - Not implemented")
fold(RDIVx):
            abort("Fold RDIVx - Not implemented")

set value:
            pop stack
set unary:
            top_disp = value
            %return
fold(CONCx):
            abort("Fold CONCx - Not implemented")

            !--------------------------------------------------------------------
            ! String operations - the only one is concatenate...
oper(CONCx):
            %if (assign pending # 0) %start
                ! It's S = S.T
                amap(lhs)
                loadreg(lhs, any)
                dumpur(PUSH, lhs_base)
                amap(rhs)
                loadreg(rhs, any)
                dumpur(PUSH, rhs_base)
                pop rel
                pop rel
                dumppushi(0, lhs_size, 0)
                %if (lookaheadiCode = iCodeASSVAL) %then perm(sconc, 3) %else perm(sjconc, 3)
                ! and finally, skip the pending assignment, and drop the LHS
                next iCode

                pop rel

                %return
            %finish

            ! here we've got T.U - if T is already in a WORK location
            ! we've got a simple append.  If it is a user variable, we've
            ! got to both copy it to a temp area and do the append
            %if (Is Work(lhs) = 0) %start
                ! Not a work area
                work = getwork(256)
                push const(work)
                top_form = av in s
                top_base = EBP
                loadreg(top, any)
                dumpur(PUSH, top_base)
                pop rel
                amap(lhs)
                loadreg(lhs, any)
                dumpur(PUSH, lhs_base)
                release(lhs_base)
                dumppushi(0, 255, 0)
                perm(smove, 3)
                ! Now we need to redefine the LHS as our temporary area
                ! gratuitous clear-it-all-out
                lhs = 0
                lhs_type = string
                lhs_form = V in S
                lhs_base = EBP
                lhs_disp = work
                lhs_size = 255
            %finish

            ! Here we are doing an in-situ concatenation
            ! We want to leave the result as a normal variable, so we
            ! suck up a copy for the AMAP fiddling
            push copy(lhs)
            amap(top)
            loadreg(top, any)
            dumpur(PUSH, top_base)
            poprel
            amap(rhs)
            loadreg(rhs, any)
            dumpur(PUSH, rhs_base)
            pop rel
            dumppushi(0, lhs_size, 0)
            perm(sconc, 3)
            %return
Reals:
            %if (op < Unaries) %then loadreg(lhs, anyf)
            %if (op # REXPx) %then loadreg(rhs, anyf)
            ->roper(op)

roper(NEGx):
roper(ABSx):
            dumpfloprr(flopmap(op), rhs_base, rhs_base)
            %return

roper(ADDx):
roper(MULx):
            ! Commutative, so we don't care
            %if (lhs_base > rhs_base) %then swap
            dumpfloprr(flopmap(op), lhs_base, rhs_base)
            pop rel
            %return

roper(SUBx):
roper(DIVx):
roper(RDIVx):
            ! We can't swap these, so we use the reverse form of
            ! the opcode (which in our internal form is always one
            ! more than the basic opcode index)
            op = flopmap(op)
            %if (lhs_base > rhs_base) %start
                swap
                op = op + 1
            %finish
            dumpfloprr(op, lhs_base, rhs_base)
            pop rel
            %return

roper(REXPx):
            ! This is implemented as a PERM routine
            loadreg(rhs, any)
            dumpur(PUSH, rhs_base)
            pop rel
            ! The usual slightly clunky floating point "push"
            work = ptreg
            dumpri(SUB, ESP, 8)
            dumprr(MOV, work, ESP)
            dumpfloprm(FSTQ, work, 0, 0)
            release(lhs_base)
            perm(fexp, 1 + (8//word size))
            ! Since rexp is actually a standard C routine, the result will
            ! be on the FPU stack
            ! JDM JDM All perm routines have been re-written in IMP
            lhs_base = FR0
            claim(FR0)
            fpu stack = 1
            lhs_form = V in R
            lhs_type = lreal
            %return

roper(NOTx):
            abort("NOTx: Unsupported Real Operation")

roper(ANDx):
            abort("ANDx: Unsupported Real Operation")

roper(ORx):
            abort("ORx: Unsupported Real Operation")

roper(XORx):
            abort("XORx: Unsupported Real Operation")

roper(REMx):
            abort("REMx: Unsupported Real Operation")

roper(LSHx):
            abort("LSHx: Unsupported Real Operation")

roper(RSHx):
            abort("RSHx: Unsupported Real Operation")

roper(EXPx):
            abort("EXPx: Unsupported Real Operation")

        %end
        !     Operation

        ! Store the item in RHS to LHS.  Encapsulates the difficulties
        ! of variable length items and pushing things on the stack to
        ! keep the rest of "Assign" looking tidy
        %routine Store( %record(stackfm)%name lhs, rhs)
            %integer pt

            %switch target(integer:lreal)
            %label esac

            ! JDM JDM added for temporary debug
            %if (diagnose&4 # 0) %start
                monitor(lhs, "STORE LHS")
                monitor(rhs, "STORE RHS")
            %finish

            -> target(lhs_type) %if (integer <= lhs_type <= lreal)
            abort("Illegal function type (".itos(lhs_type,0).") for Store")

            target(integer):
            target(long):
                %if (lhs_base = ESP) %start
                    %if (rhs_type = byte) %start
                        loadreg(rhs, any)
                        dumpvpush(rhs)
                    %finish %else %if (rhs_type = short) %start
                        loadreg(rhs, any)
                        dumpvpush(rhs)
                    %finish %else %start
                        address(rhs)
                        dumpvpush(rhs)
                    %finish
                %finish %else %if (rhs_form = constant) %and (rhs_scope = 0) %start
                    dumpmi(MOV, lhs_base!lhs_scope, lhs_disp, lhs_extdisp, rhs_disp)
                %finish %else %start
                    loadreg(rhs, any)
                    dumpmr(MOV, lhs_base!lhs_scope, lhs_disp, lhs_extdisp, rhs_base)
                %finish
                -> esac

            target(short):
                ! JDM JDM added for temporary debug
                %if (diagnose&4 # 0) %start
                    monitor(lhs, "STORE SHORT LHS")
                    monitor(rhs, "STORE SHORT RHS")
                %finish

                %if (lhs_base = ESP) %start
                    %if (rhs_type = byte) %start
                        loadreg(rhs, any)
                        dumpvpush(rhs)
                    %finish %else %if (rhs_type = short) %start
                        loadreg(rhs, any)
                        dumpvpush(rhs)
                    %finish %else %start
                        address(rhs)
                        dumpvpush(rhs)
                    %finish
                %finish %else %if (rhs_form = constant) %and (rhs_scope = 0) %start
                    ! JDM JDM Remember rhs_disp contains a signed 32-bit integer constant value
                    ! So the signed 32-bit integer range allowed for a %short (== 16-bit signed integer)
                    ! has bit range 16_00000000:16_00008000 or 16_FFFF8000:16_FFFFFFFF
                    ! noting that 16_00008000 will be -32768 (when sign-extended to be 16_FFFF8000)
                    ! These then correspond to 32-bit integer values 0:32768 or -32768:-1
                    ! So a 16-bit integer must be in the 32-bit integer range -32768:-1 or 0:32768
                    ! Thus check for values in the 32-bit integer range -32768:32768

                    warn(9) %unless (-32768 <= rhs_disp <= 32768)

                    ! JDM JDM We should add code to MOV a truncated %short constant to the LHS
                    ! but for Intel x86 we can only MOV a 32-bit integer or an 8-bit byte

                    ! Therefore, move the constant as 2 bytes
                    ! store the "low" byte
                    dumpmi8(MOV, lhs_base!lhs_scope, lhs_disp, lhs_extdisp, rhs_disp&255)
                    ! store the "hi" byte
                    dumpmi8(MOV, lhs_base!lhs_scope, lhs_disp+1, lhs_extdisp+1, (rhs_disp>>8)&255)
                %finish %else %if (rhs_type = short) %start
                    %if (rhs_extra=8) %start
                        ! now store the un-validated %short value
                        ! RHS is a %function so value is in %EAX
                        dumpmr8(MOV, lhs_base!lhs_scope, lhs_disp, lhs_extdisp, AL )
                        dumpmr8(MOV, lhs_base!lhs_scope, lhs_disp+1, lhs_extdisp+1, AH )
                    %finish %else %if (rhs_form = V in R) %start
                        ! now store the un-validated %short value
                        ! store the "low" byte
                        dumpmr8(MOV, lhs_base!lhs_scope, lhs_disp, lhs_extdisp, AL + rhs_base - EAX )
                        ! store the "hi" byte
                        dumpmr8(MOV, lhs_base!lhs_scope, lhs_disp+1, lhs_extdisp+1, AH + rhs_base - EAX )
                        dumpmi8(AND, lhs_base!lhs_scope, lhs_disp, lhs_extdisp, 16_FF )
                        dumpmi8(AND, lhs_base!lhs_scope, lhs_disp+1, lhs_extdisp+1, 16_FF )
                    %finish %else %start
                        ! try to avoid pointless promoting to an int
                        ! We will reproduce a "Load" but without the word extension
                        address(rhs)
                        pt = gp reg
                        ! convert the pt to be in the EAX..EBX range
                        dumprm(MOV, pt, rhs_base!rhs_scope, rhs_disp, rhs_extdisp )
                        release(rhs_base)
                        rhs_base = pt
                        rhs_form = V in R
                        rhs_type = Integer
                        claim(pt)

                        ! now store the %short value
                        ! Convert the rhs register to be in the AL..BH range
                        ! store the "low" byte
                        dumpmr8(MOV, lhs_base!lhs_scope, lhs_disp, lhs_extdisp, AL + rhs_base - EAX)
                        ! store the "hi" byte
                        dumpmr8(MOV, lhs_base!lhs_scope, lhs_disp+1, lhs_extdisp+1, AH + rhs_base - EAX)
                    %finish
                %finish %else %if (rhs_type = byte) %start
                    %if (rhs_extra=8) %start
                        ! RHS is a %function so value is in %EAX
                        dumpmr(MOV, lhs_base!lhs_scope, lhs_disp, lhs_extdisp, EAX )
                    %finish %else %start
                        ! try to avoid pointless promoting to an int
                        ! We will reproduce a "Load" but without the word extension
                        address(rhs)
                        pt = gp reg
                        ! convert the pt to be in the AL..BH range
                        dumprm8(MOV, AL + pt - EAX, rhs_base!rhs_scope, rhs_disp, rhs_extdisp )
                        release(rhs_base)
                        rhs_base = pt
                        rhs_form = V in R
                        rhs_type = Integer
                        claim(pt)
                        ! Convert the rhs register to be in the AL..BH range
                        ! store the "low" byte
                        dumpmr8(MOV, lhs_base!lhs_scope, lhs_disp, lhs_extdisp, AL + rhs_base - EAX)
                        ! store the "hi" byte
                        dumpmr8(MOV, lhs_base!lhs_scope, lhs_disp+1, lhs_extdisp+1, AH + rhs_base - EAX)
                    %finish
                %finish %else %start
                    loadreg(rhs, any)
                    ! ABD - should add a capacity check here
                    ! Convert the register to be in the AL..BH range
                    ! store the "low" byte
                    dumpmr8(MOV, lhs_base!lhs_scope, lhs_disp, lhs_extdisp, AL + rhs_base - EAX)
                    ! store the "hi" byte
                    dumpmr8(MOV, lhs_base!lhs_scope, lhs_disp+1, lhs_extdisp+1, AH + rhs_base - EAX)
                %finish

                -> esac

            target(byte):
                %if (lhs_base = ESP) %start
                    %if (rhs_type = byte) %start
                        loadreg(rhs, any)
                        dumpvpush(rhs)
                    %finish %else %start
                        address(rhs)
                        dumpvpush(rhs)
                    %finish
                %finish %else %if (rhs_form = constant) %and (rhs_scope = 0) %start
                    ! Remember rhs_disp contains a signed 32-bit integer constant value
                    ! So the signed 32-bit integer range allowed for a %byte (== 8-bit unsigned integer)
                    ! has bit range 16_00000000:16_000000FF
                    ! These then correspond to 32-bit integer values 0:255
                    ! So an 8-bit byte must be in the 32-bit integer range 0:255
                    ! Thus check for values in the 32-bit integer range 0:255

!                    warn(8) %unless (0 <= rhs_disp <= 255)
                    warn(8) %unless (-256 <= rhs_disp <= 255)

                    ! Do an immediate to memory MOV on the byte value in rhs_disp
                    dumpmi8(MOV, lhs_base!lhs_scope, lhs_disp, lhs_extdisp, rhs_disp&255)
                %finish %else %if (rhs_type = byte) %start
                    %if (rhs_extra=8) %start
                        ! RHS is a %function so value is in %EAX
                        dumpmr(MOV, lhs_base!lhs_scope, lhs_disp, lhs_extdisp, EAX )
                    %finish %else %start
                        ! try to avoid pointless promoting to an int
                        ! We will reproduce a "Load" but without the word extension
                        address(rhs)
                        pt = gp reg
                        ! convert the pt to be in the AL..BH range
                        dumprm8(MOV, AL + pt - EAX, rhs_base!rhs_scope, rhs_disp, rhs_extdisp )
                        release(rhs_base)
                        rhs_base = pt
                        rhs_form = V in R
                        rhs_type = Integer
                        claim(pt)
                        ! Convert the rhs register to be in the AL..BH range
                        dumpmr8(MOV, lhs_base!lhs_scope, lhs_disp, lhs_extdisp, AL + rhs_base - EAX)
                    %finish
                %finish %else %start
                    loadreg(rhs, any)
                    ! ABD - should add a capacity check here
                    ! Convert the register to be in the AL..BH range
                    dumpmr8(MOV, lhs_base!lhs_scope, lhs_disp, lhs_extdisp, AL + rhs_base - EAX)
                %finish
                -> esac

            target(real):
                %if (lhs_base = ESP) %start
                    loadreg(rhs, anyf)
                    pt = pt reg
                    dumpri(SUB, ESP, 4)
                    dumprr(MOV, pt, ESP)
                    dumpfloprm(FSTD, pt, 0, 0)
                %finish %else %start
                    loadreg(rhs, anyf)
                    dumpfloprm(FSTD, lhs_base!lhs_scope, lhs_disp, lhs_extdisp )
                %finish
                -> esac

            target(lreal):
                %if (lhs_base = ESP) %start
                    loadreg(rhs, anyf)
                    pt = pt reg
                    dumpri(SUB, ESP, 8)
                    dumprr(MOV, pt, ESP)
                    dumpfloprm(FSTQ, pt, 0, 0)
                %finish %else %start
                    loadreg(rhs, anyf)
                    dumpfloprm(FSTQ, lhs_base!lhs_scope, lhs_disp, lhs_extdisp )
                %finish
                -> esac

            target(string):
            target(record):
                ! We should never get passed a string/record variable
                -> esac

            esac:
        %end

        !                                                          >> ASSIGN <<
        ! ASSOP =   -1:  parameter assignment
        !            0:  == assignment
        !            1:  =  assignment
        !            2:  <- assignment
        %routine  assign(%integer  assop )
            %record(stackfm)%name  lh,rh
            %record(stackfm)  temp
            %integer  n
            %integer  p
            %integer  r

            abort("Assign Stack") %if (stp < 2)

            rh == top
            lh == stack(stp-1)

            %if (diagnose&4 # 0) %start
                monitor(lh, "ASS LH")
                monitor(rh, "ASS RH")
            %finish

            %if same(lh, rh) %then %start
                pop rel
                pop rel
                %return
            %finish

            %if (assop < 0) %start
                ! Parameter

                %if (lh_base >= 128) %start
                    ! Special - prim routine

                    ! JDM JDM comment
                    ! The next iCode should be CALL (if not then an ERROR has arisen)
                    ! So swop the stack entries ensuring the internal macro has valid parameters
                    temp = lh
                    lh = rh
                    rh = temp
                    %return
                %finish

                ! Extract the next formal parameter and make it our target
                lh_pbase = lh_pbase - 1
                Stack Var(lh_pbase)
                ! Now make our destination look reasonable
                lh == top

                ! target is the stack
                lh_base = ESP
 
                ! %name parameter is '=='
                assop = 0 %if (lh_form # V in S)

                ! We need special treatment for procedure parameters
                %if (switch < lh_aform < array) %start
                    ! this is a procedure

                    ! we will treat it as a value assignment
                    assop = 1

                    ! of an integer
                    rh_type = integer
                    lh_type = integer
                    lh_form = V in S
                    %if (rh_base # 0) %start
                        ! RH is already a parameter
                        rh_form = V in S
                    %finish %else %if (rh_scope = EXT) %start
                        ! it is an external procedure
                        ! pick up the address
                        rh_form = A V in S
                    %finish %else %start
                        ! it is a local procedure
                        ! HACK: local procedures are Tags until Pass3 fixes them up.  The
                        ! only way we have of converting tags to addresses is with the switch
                        ! table - so we'll plant a fake switch entry for the label of the
                        ! local routine, and then load that value!
                        %if (swtp >= Max Switch) %then abort("Proc - Switch Table Full")
                        swtab(swtp) = rh_disp
                        rh_disp = swtp * word size
                        swtp = swtp+1
                        rh_scope = SWT
                        rh_form = V in S
                    %finish
                %finish
            %finish

            %if (array <= rh_aform <= namearrayname) %start
                ! Arrayname
                ! An array name is two words - a pointer to the data and a
                ! pointer to the dope vector.  If the RHS is already one of these
                ! then we just want to copy the two words.  If it is a static
                ! array, we need to map the data to make a pointer, and its' dope
                ! vector will be in the constant table, so we fetch that.
                amap(lh)
                address(lh)

                ! This works because arrays are stacked as V in S, arraynames are A in S
                amap(rh)
                address(rh)

                ! We do the dope vector first - that makes it easier when we're parameter passing
                %if (rh_aform = array) %or (rh_aform = name array) %start
                    ! simple static - DV in COT
                    ! We will rustle up a dummy record for the DV address
                    temp = 0
                    temp_form = A V in S
                    temp_type = integer
                    temp_disp = rh_pbase
                    temp_scope = COT
                %else
                    ! already an array name
                    temp = rh
                    claim(temp_base)
                    temp_disp = temp_disp + word size
                %finish
                lh_disp = lh_disp + word size
                store(lh, temp)
                release(temp_base)
                lh_disp = lh_disp - word size
                store(lh, rh)
                pop rel
                pop rel
                %return
            %finish

            %if (lh_type = general) %start
                ! general %name parameter

                ! Only '==' is allowed
                abort("Assign GenName") %unless (assop = 0)

                ! A general name pointer is two words
                ! - the pointer itself
                ! and
                ! - a second word to convey type information.
                ! If the RHS is already one of these guys it's easy
                !   just copy the two words.
                ! else
                !   we must rustle up the second word at compile time

                amap(lh)
                address(lh)
                %if (rh_type = general) %start
                    ! RHS already a general pointer
                    ! so, make a copy for the second word
                    temp = rh
                    claim(temp_base)
                    temp_disp = temp_disp + word size
                    amap(temp)
                %else
                    ! RHS not a general pointer
                    ! so, rustle up the second word
                    temp = 0
                    temp_type = integer
                    ! load the values for sizeof, typeof
                    %if (rh_type = string) %start
                        temp_disp = (rh_size + 1)<<4
                    %finish %else %start
                        temp_disp = (rh_size<<4)
                    %finish
                    temp_disp = temp_disp + gen map(rh_type)

                    ! DANGER! this second word needs to be differentiated
                    ! from a DVP pointer
                    ! JDM JDM make temp_disp an odd number
                    temp_disp = (temp_disp<<1) + 1
                %finish

                ! We do the words backwards, so that parameter push works
                lh_disp = lh_disp + word size
                store(lh, temp)
                release(temp_base)
                lh_disp = lh_disp-word size
                amap(rh)
                store(lh, rh)
                pop rel
                pop rel
                %return
            %finish

            %if (assop = 0) %start
                ! ==

                %if (diagnose&4 # 0) %start
                    monitor(lh, "ASS LH ==")
                    monitor(rh, "ASS RH ==")
                %finish

                ! destination
                amap(lh)

                ! ABD %string( * )%name  NOT handled special here - should be?
                amap(rh)
            %finish

            %if (lh_type = record) %start

                %if (diagnose&4 # 0) %start
                    monitor(lh, "ASS LH RECORD")
                    monitor(rh, "ASS RH RECORD")
                %finish

                %if (lh_base = ESP) %start
                    ! pass record by value - destination is the stack
                    n = lh_size
                    hazard(EDI)
                    dumpri(SUB, ESP, lh_size)
                    dumprr(MOV, EDI, ESP)
                    claim(EDI)
                    lh_base = EDI
                %else
                    n = Min Record Size(Lh, Rh)
                    amap(lh)
                    loadreg(lh, EDI)
                %finish
                hazard(ECX)
                dumpri(MOV, ECX, n)
                %if (rh_Form = Constant) %start
                    hazard(EAX)
                    ! Sneaky trick to get a zero
                    dumprr(XOR, EAX,EAX)
                    dumprepstosb
                %else
                    amap(rh)
                    loadreg(rh, ESI)
                    dumprepmovsb
                %finish
!                ! Free up the EDI, ESI registers after this record assignment
!                release(DI)
!                release(SI)
                pop rel
                pop rel
                %return
            %finish

            %if (lh_type = string) %start
                %if (assop > 0) %and (rh_format = 1) %start
                    ! null string as zero byte ?
                    lh_type = byte

                    ! zap current RHS
                    pop rel

                    ! get a zero
                    push const(0)

                    ! and assign it
                    assign(assop)
                    %return
                %finish

                ! our copy routines expect DEST then SOURCE then LENGTH on the stack
                %if (lh_base = ESP) %start
                    ! pass string by value - destination is the stack
                    ! space is string size, plus one for length, plus make it even
                    p = lh_size + 1
                    p = (p+align) & (\align)
                    dumpri(SUB, ESP, p)
                    ! we want to Push ESP here - sadly different versions of x86
                    ! architecture have different interpretations of "PUSH ESP", so...
                    r = gp reg
                    dumprr(MOV, r, ESP)
                    dumpur(PUSH, r)
                %else
                    amap(lh)
                    loadreg(lh, any)
                    dumpur(PUSH, lh_base)
                %finish
                ! It is likely that the RH variable is a temporary work area
                ! Before we trash the information, we try to release it
                Return Work(rh_disp)
                amap(rh)
                loadreg(rh, any)
                dumpur(PUSH, rh_base)
                pop rel
                pop rel
                dumppushi(0, lh_size, 0)
                %if (assop = 2) %then perm(sjam, 3) %else perm(smove, 3)
                %return
            %finish

            address(lh)
            store(lh, rh)
            pop rel
            pop rel
        %end
        !  assign

        !                                                      >> ARRAY REF <<
        ! Array references always use the PERM
        ! unless they are 1 dimensional,
        ! AND the %control bit has been turned off
        %routine  array ref(%integer mode)
            %record(stackfm)%name av
            %integer type, form, size, format

            %if (mode # 0) %then %start
                ! Put non-terminal index onto stack for PERM
                %if (top_type = byte) %start
                    loadreg(top, any)
                %else
                    address(top)
                %finish
                dumpvpush(top)
                pop rel
                %return
            %finish
   
            av == stack(stp-1)
            size = av_size
            size = size + 1 %if (av_type = string)
            form = av_aform
            %if (form=namearray) %or (form=namearrayname) %then size = word size

            %if (control&check array = 0) %and (av_dim = 1) %start
                ! This will be unchecked, the top of the stack is the only index (1D),
                ! so we can do a cheap multiplication here
                %if (size # 1) %start
                    ! multiply offset by var size
                    push const(size)
                    Operation(MULx)
                %finish
            %else
                ! This is the final (and perhaps only) subscript for a checked array,
                ! so we are going to use the Perm - therefore pass this as a parameter
                %if (top_type = byte) %start
                    loadreg(top, any)
                %else
                    address(top)
                %finish
                dumpvpush(top)
                pop rel
            %finish

            ! How we do the rest of the access depends on whether this is a simple
            ! static array, or an array name...

            %if (form = arrayname) %or (form = namearrayname) %start
                ! array is a "name"
                ! We will AMAP the name,
                ! so we remember the info and then put it all back later
                type = av_type
                format = av_format
                size = av_size
                %if (form = arrayname) %then form = V in S %else form = A in S
                amap(av)

                %if (control&check array # 0) %or (av_dim > 1) %start
                    ! do the rest of the check
                    ! This is a bit clunky, because we may load registers in order
                    ! to access AV, only to Hazard them for the PERM
                    address(av)
                    push copy(av)
                    claim(top_base)

                    ! Dope Vector address follows A(0)
                    top_disp = top_disp + word size
                    dumpvpush(top)
                    pop rel
                    ! DV word, plus a word for every subscript
                    perm(aref, av_dim + 1)
                    push const(0)
                    top_form = V in R
                    top_base = EAX
                    claim(EAX)
                %finish

                ! make sure index is in a pointer register
                loadreg(top, anyp)
                Operation(ADDx)
                top_type = type
                top_form = form
                top_format = format
                top_size = size
                top_disp = 0
            %else
                ! simple arrays are always 1D, but can still be checked
                %if (control&check array # 0) %start
                    ! Pass a pointer to the Dope Vector
                    ! simple arrays have compile-time DV's in the COT
                    dumppushi(COT, av_pbase, 0)
                    perm(aref, 2)
                    push const(0)
                    top_form = V in R
                    top_base = EAX
                    claim(EAX)
                %finish

                address(av)
                %if (av_form # V in S) %then abort("Aref Form")
                %if (top_form = constant) %start
                    ! simple constant a(k)
                    ! just add it to the offset
                    av_disp = av_disp + top_disp
                %else
                    ! pick up index in a pointer
                    loadreg(top, anyp)
                    %if (av_base # 0) %start
                        ! add the base we've already got
                        dumprr(ADD, top_base, av_base)
                        release(av_base)
                    %finish
                    av_base = top_base
                %finish
                %if (form = array) %then av_form = V in S %else av_form = A in S
                pop stack
            %finish

            ! not an array any more
            top_aform = 0

        %end
        !  array ref

        !                                              >> TEST ZERO <<
        ! test a real/integer/byte variable against zero
        %routine  test zero(%record(stackfm)%name  v)

            %if (v_type = integer) %or (v_type = byte) %or (v_type = short) %start
                loadreg(v,any)
                dumpri(CMP, v_base, 0)
            %else
                abort("Test Zero")
            %finish
        %end
        ! test zero

        %routine Compare Records(%record(stackfm)%name L, R, %integer N)
            ! JDM JDM eventually compare the byte values of each record
            ! in the interim, barf
            abort("Compare Records")
        %end

        !                                              >> COMPARE REALS <<
        %routine  compare reals(%record(stackfm)%name  l,r)
            loadreg(l, anyf)
            loadreg(r, anyf)
            hazard(EAX)
            ! who's ended up on top?
            ! l_base is the top of the FPU stack
            %if (l_base > r_base) %start
                dumpfloprr(FCMP, r_base, l_base)
            %else
                dumpfloprr(FCMP, l_base, r_base)
                invert = invert !! 1
            %finish
            ! puts status into EAX
            dumpflopspec(FSTSW)
            ! and move it to flags
            dumpsimple(SAHF)
            ! because FPU reports as if operands were unsigned
            compare unsign = 1
        %end
        ! compare reals

        !                                              >> COMPARE STRINGS <<
        %routine  compare strings(%record(stackfm)%name  l,r)
            %record(stackfm)%name  temp
            %if (l_base = COT) %and (l_disp = null string) %start
                temp == r
                r == l
                l == temp
                invert = invert !! 1
            %finish
            %if (r_base = COT) %and (r_disp = null string) %start
                l_type = byte
                test zero(l)
            %else
                amap(l)
                loadreg(l, any)
                dumpur(PUSH, l_base)
                amap(r)
                loadreg(r, any)
                dumpur(PUSH, r_base)
                perm(scomp, 2)
                dumpri(CMP, EAX, 0)
            %finish
        %end
        ! compare strings

        !                                              >> COMPARE <<
        %routine  compare(%record(stackfm)%name  l,r)
            %if (l_type = 0) %or (l_type = string) %start
                compare strings(l,r)
                %return
            %finish
            %if floating(l) %or floating(r) %start
                compare reals(l,r)
                %return
            %finish
            %if zero(r) %start
                test zero(l)
                %return
            %finish
            %if zero(l) %start
                test zero(r)
                invert = invert !! 1
                %return
            %finish
            %if (l_Type = Record) %start
                Compare Records(L, R, Min Record Size(L, R))
                %return
            %finish
            loadreg(l,any)
            %if (r_type = byte) %start
                loadreg(r, anyg)
            %else
                address(r)
            %finish
            dumprv(CMP, l_base, r)
        %end
        ! compare

        !                                              >> RESOLVE <<
        %routine  resolve( %integer  flag )

            ! JDM JDM debug show the iCode instruction
            %if (diagnose&16 # 0) %start
                ListICode
                spaces(4)
                printstring( itos(flag,0) )
                newline
            %finish
            ! JDM JDM end debug

            !S -> A.(B).C
            %if (flag&1 = 0) %then push const(0) %else amap(top); ! C missing?
            loadreg(top, any)
            dumpur(PUSH, top_base)
            pop rel
            amap(top);  ! B
            loadreg(top, any)
            dumpur(PUSH, top_base)
            pop rel
            %if (flag&2 = 0) %then push const(0) %else amap(top); ! A missing?
            loadreg(top, any)
            dumpur(PUSH, top_base)
            pop rel
            amap(top);  ! S
            loadreg(top, any)
            dumpur(PUSH, top_base)
            pop rel
            perm(sresln, 4)
            %if (flag&4 # 0) %then dumpri(CMP, EAX, 0)
        %end
        ! resolve

        %integerfn enter
            %integer cad;

            uncond jump = -1; ! can get here

            ! This is a convenient place to include external definitions if needed
            %if (potype >= external) %start
                fill external(CODE, external id)
            %finish

            cad = nextcad;
            dumpstaticalloc(cad, level, block name); ! plant dummy ENTER instruction and pass marker to pass 3
            %result = cad;
        %end

        !                                              >> DUMP RETURN <<
        %routine  dump return
            %return %if (uncond jump = next cad);          !  can't get here ?

            ! Pure 8086 would need these two
            !   dumprr(MOV, ESP, EBP)
            !   dumpur(POP, EBP)
            ! but now we use this instead...
            dumpsimple(LEAVE)

            dumpsimple(RET);

            uncond jump = next cad
        %end
        ! return

        ! Routine to do "to string" as an in-line, either by making
        ! a constant string in the CONST area, or putting one onto
        ! the current workspace
        %routine  compile to string(%record(stackfm)%name  v)
            %integer tmp

            %if const(v) %start
                current string(0) = 1
                current string(1) = v_disp&255
                v_base = 0
                v_scope = COT
                v_disp = getcots(current string)
            %else
                tmp = getwork(word size)
                loadreg(v,anyg);        ! Must be a byte-addressable register
                dumpmi(MOV, EBP, tmp, 0, 1)
                ! Convert the register to be in the AL..BH range
                dumpmr8(MOV, EBP, tmp+1, 0, AL + v_base - EAX)
                release(v_base)
                v_base = EBP
                v_scope = 0
                v_disp = tmp
            %finish
            v_type = string
            v_form = V in S
            v_size = 1
        %end

        !                                              >> COMPILE CALL <<
        ! Call the routine on the top of the stack.  Note - the parameters
        ! are all hidden underneath the routine, so we need to push them
        ! here
        %routine  Compile Call(%record(stackfm)%name  v)
            %label form new type
            ! switch b used for prim macro functions
            %switch  b(1:14)

            !  1 = rem
            !  2 = float
            !  3 = to string
            !  4 = addr
            !  5 = integer
            !  6 = byte integer
            !  7 = string
            !  8 = record
            !  9 = real
            ! 10 = long real
            ! 11 = length
            ! 12 = charno
            ! 13 = int (from real)
            ! 14 = short integer

            %conststring(15) %array macroname(1:14) =
            {  1 } "REM",
            {  2 } "FLOAT",
            {  3 } "TO STRING",
            {  4 } "ADDR",
            {  5 } "INTEGER",
            {  6 } "BYTE INTEGER",
            {  7 } "STRING",
            {  8 } "RECORD",
            {  9 } "REAL",
            { 10 } "LONG REAL",
            { 11 } "LENGTH",
            { 12 } "CHARNO",
            { 13 } "INT",
            { 14 } "SHORT INTEGER"

            %constbyteintegerarray  new type(5:14) =
                      integer, byte, string, record, real, lreal, byte, byte, integer, short
            %integer  t,l,p

            %if (v_base >= 128) %start
                !  built-in primitive
                l = 0;
                t = v_disp

                pop rel

                ! JDM JDM defend against out-of-range value for t
                t = 0 %unless (0 < t < 16)
                abort("Illegal %prim macro") %unless (0 < t < 15)

!                ! JDM JDM show start of macro "call" in listing
!                ! Now to say which macro was requested 
!                 %if (diagnose&16 # 0) %start
!                        selectoutput(listout)
!                        spaces(38)
!                        printstring( "Generating CODE for '" )
!                        printstring( macroname(t) )
!                        printstring( "' (MACRO ".itos(t,0).")")
!                        newline
!                %finish

                -> b(t)
b(1):
                ! REM
                Operation(REMx)
                                                       -> esac
b(2):
                ! FLOAT
                loadreg(top, anyf)
                                                       -> esac
b(3):
                ! TO STRING
                compile to string(top)
                                                       -> esac
b(4):
                ! ADDR
                amap(top)
                                                       -> esac
b(5):
                ! INTEGER
b(6):
                ! BYTE
b(7):
                ! STRING
b(8):
                ! RECORD
b(9):
                ! REAL
b(10):
                ! LONG REAL
b(14):
                ! SHORT

form new type:
                vmap(top)
                top_type = new type(t)
                top_size = v size(top_type)
                                                       -> esac

b(11):
                ! LENGTH
                push const(0);                      ! length is charno zero
                amap(stack(stp-1))
                Operation(ADDx);  !LHS&RHS reversed in Operation??

                ! JDM JDM avoid code duplication
                                                       -> form new type
b(12):
                ! CHARNO
                amap(stack(stp-1))
                Operation(ADDx);  !LHS&RHS reversed in Operation??

                ! JDM JDM avoid code duplication
                -> form new type
b(13):
                ! INT(real)
                loadreg(top, anyf)
                release(top_base)
                p = getwork(word size)
                top_type = new type(t)
                top_form = V in S
                top_base = EBP
                top_disp = p
                top_size = word size
                dumpfloprm(FSTI, top_base, top_disp, 0 )
                top_scope = 0

                                                -> esac

esac:
!                ! JDM JDM show macro "call" in listing
!                ! Now to say which macro was requested
!                %if (diagnose&16 #0) %start
!                    spaces(38)
!                    printstring( "CALL '" )
!                    printstring( macroname(t) )
!                    printstring( "' (MACRO ".itos(t,0).")")
!                    newline
!                %finish

            %finish %else %start
                !   -- normal routine calls --
                ! String functions have a hidden last parameter to point
                ! to the result area
                ! JDM JDM attempt to obtain return value of %record %function
                ! temporary debug call to show(v) to determine function %result
!                %if (diagnose&16 # 0) %then show(v)

                ! JDM JDM
                ! %record / %string functions have a "hidden" parameter
                ! which is used to store the function result
                ! %real / %longreal has %result on the FPU stack
                ! All other function results %byte / %short / %integer / %predicate?
                ! will have the %result returned in the %EAX register.
                %if (v_type = record) %and (v_aform = 8) %start
                    ! Calling a function which returns a %record
                    t = getwork(v_size)
                    p = gp reg
                    dumprm(LEA, p, EBP, t, 0)
                    dumpur(PUSH, p)
                %finish %else %if (v_type = string) %and (v_aform = 8) %start
                    ! Calling a function which returns a %string
                    t = getwork(v_size+1)
                    p = gp reg
                    dumprm(LEA, p, EBP, t, 0)
                    dumpur(PUSH, p)
                %finish
                hazard all
                %if (v_scope = EXT) %start
                    ! external
                    dumpextcall(v_disp)
                %finish %else %if (v_base # 0) %start
                    ! procedure-as-parameter
                    ! so, plant call indirect through variable
                    dumpum(CALL, v_base, v_disp, v_extdisp )
                %finish %else %start
                    ! local routine
                    ! plants fixup for the tag
                    dumpjump(CALL, v_disp)
                %finish
                ! adjust the stack
                %if (v_extra # 0) %then dumpri(ADD, ESP, v_extra)
                %if (v_type = 0) %start
                    ! not function or map
                    pop rel
                %finish %else %start
                    ! Here we've got a result
                    ! Result is local, even if the function wasn't
                    v_scope = 0
                    %if (v_type = string) %and (v_aform = 8) %start
                        ! JDM JDM added comment to indicate %result type
                        ! a %string was returned
                        v_base = EBP;             ! String result will have been copied back here
                        v_disp = t
                        v_form = V in S
                    %finish %else %if (v_type = record) %and (v_aform = 8) %start
                        ! JDM JDM added comment to indicate %result type
                        ! a %record was returned
                        v_base = EBP;             ! record result will have been copied back here
                        v_disp = t
                        v_form = V in S
                    %finish %else %if ((v_type = real) %or (v_type = lreal)) %and (v_aform = 8) %start
                        ! JDM JDM added comment to indicate %result type
                        ! a %real / %longreal was returned
                        ! Floating result will be on the FPU stack
                        v_form = V in R
                        v_base = FR0
                        claim(FR0)
                        fpu stack = 1
                    %finish %else %start
                        ! JDM JDM added comment to indicate %result type
                        ! a %byte / %short / %integer / %name? / %predicate? was returned
                        ! Result is always in EAX
                        v_base = EAX
                        v_disp = 0;                ! Clear this for MAP results
                        claim(EAX)
                    %finish
                %finish
            %finish
        %end;
        !  Compile Call

        !                                              >> COMPILE FOR <<
        %routine  compile for( %integer lab )
            %record(stackfm)%name  cv, iv, inc, fv
            %integer  n

            ! JDM JDM debug show the iCode instruction
            %if (diagnose&16 # 0) %start
                ListICode
                spaces(4)
                printstring( itos(lab,0) )
                newline
            %finish
            ! JDM JDM end debug

            ! Lock a value into a temporary to make sure it is invariant
            %routine  stab(%record(stackfm)%name  v,  %integer  type)
                %integer  t,r
                %return %if const(v)
                loadreg(v,any)
                r = v_base
                t = getwork(word size)
                dumpmr(MOV, EBP,t, 0, r)
                v_base = EBP
                v_disp = t
                v_scope = 0
                v_type = type
                v_form = V in S
                release(r)
            %end

            iv == top
            fv == stack(stp-1)
            inc == stack(stp-2)
            cv == stack(stp-3)

            stab(fv,integer)
            stab(inc,integer)

            ! Check control variable is a plain value - otherwise save a pointer to it
            ! in case it changes
            %if (cv_form # v in s) %or ((0 < cv_base <= EDI) %and (cv_base # EBP)) %start
                n = cv_type
                amap(cv)
                stab(cv, n)
                cv_form = a in s
            %finish
   
            push copy(cv)
            push copy(iv)
            push copy(inc);
            Operation(SUBx)
            assign(1);        ! cv = iv - inc

            define label(lab)
            pop stack;! zap unwanted copy of IV

            ! Stack is now  top->[FV[INC[CV 
            push copy(cv);      ! in case compare alters it
            compare(top, fv)
            jump to(lab+1, JE, 1)
            invert = 0; ! because the compare might have flipped this (N/A for JE)
            ! Stack is now top->[CV'[FV[INC[CV where CV' is a register copy of CV
            release(fv_base)

            ! trash FV and make a copy of CV' in that slot
            fv = top

            ! discard the top copy
            pop stack
            ! stack is now top->[CV'[INC[CV
            Operation(ADDx)
            assign(1)
        %end
        ! for

        %routine End of Block
            %if (amode >= 0) %start
                ! No return code for %endoffile
                dump return

                ! don't include the display
                dumpstaticfill(staticalloc, frame+(level*word size), events, evep, evfrom)
            %finish
        %end

        %routine Compile Begin
            decvar == begin
            decvar_disp = new tag
            otype = 0
            spec = 0
            potype = 0
            %if (level # 0) %start
                ! not outermost %begin
                push const(decvar_disp)
                top_type = 0;      ! it's not a function!
                compile call(top)
                skip proc = new tag
                dump jump(JMP, skip proc)
                dump label(decvar_disp);  ! this is where to call
            %finish
            assemble(0,labs,names)
            %if (level # 0) %start
                dump label(skip proc)
                last skip = next cad
                Uncond Jump = 0
            %finish
        %end

        ! Utility routine used when dumping initialisers for OWNs
        ! Note non-portable use of real values
        %routine  adump
            %integer    i
            %real       rv32
            %switch ot(general:tlabel)

            ->ot(own type)
ot(general):
            abort("General Own?")
ot(integer):
            gput(ownval)
            -> done
ot(byte):
            gbyte(ownval)
            -> done
ot(short):
            gput(ownval)
            -> done
ot(long):
            gput(ownval)
            -> done
ot(real):
            ! because our default variable is a 64 bit long real
            ! convert to a 32 bit real
            rv32 = rvalue
            ! now store the 4 bytes of the real number
            %for i = 0,1,3 %cycle
                gbyte(byteinteger(addr(rv32)+i))
            %repeat
            -> done
ot(lreal):
            ! store the 8 bytes of the long real number
            %for i = 0,1,7 %cycle
                gbyte(byteinteger(addr(rvalue)+i))
            %repeat
            -> done
ot(string):
            %if (current string(0)+1 > data size) %start
                ! check for overflow
                ! String constant too long - warn and truncate
                warn(5)
                current string(0) = data size - 1
            %finish

            %for i = 0,1,data size - 1 %cycle
                gbyte(current string(i))
            %repeat
            -> done
ot(record):
            %for i = 1,1,data size %cycle
                gbyte(0)
            %repeat
            -> done
ot(tarray):
            %for i = 1,1,data size %cycle
                gbyte(0)
            %repeat
            -> done
ot(tlabel):
            gput(ownval)
            -> done

done:
        %end

        %integerfn user label(%integer lab)
            %record(varfm)%name v
            %if (lab > names) %start
                names = lab
                v == var(lab)
                v = 0
                v_form = pgm label
                v_disp = new tag
                %result = v_disp
            %finish
            %result = var(lab)_disp
        %end

        %routine Compare Double
            LHS == stack(stp-1)
            RHS == top
            loadreg(rhs, any)
            ! We happen to know that Compare loads the left parameter in a register.
            ! We've already got RHS in a register, so we flip the LHS and RHS to the
            ! comparison and set Invert accordingly
            compare(rhs, lhs)
            invert = 1
            ! release LH and then overwrite it with RH
            release(lhs_base)
            lhs = rhs
            pop stack
        %end

        %routine Compare Values
            LHS == stack(stp-1)
            RHS == top
            compare(lhs,rhs)
            pop rel
            pop rel
        %end

        %routine Compare Addresses
            amap(top)
            amap(stack(stp-1));                  ! Now do same as compare values
            Compare Values
        %end

        %routine Define Compiler Label( %integer label)

            ! JDM JDM debug show the iCode instruction
            %if (diagnose&16 # 0) %start
                ListICode
                spaces(4)
                printstring( itos(label,0) )
                newline
            %finish
            ! JDM JDM end debug

            %if (label = 0) %start
                dump label(skipproc)
                last skip = next cad
                Uncond Jump = 0
            %else
                define label( label )
            %finish
        %end

        %routine Init( %integer N )
            ! N = Number of values to assign
            %integer j

            ! JDM JDM debug show the iCode instruction
            %if (diagnose&16 # 0) %start
                ListICode
                spaces(4)
                printstring( itos(N,0) )
                newline
            %finish
            ! JDM JDM end debug

            %if (stp # 0) %start
                ! Value supplied?
                own val = top_disp
                %if (own type = real) %or (own type = lreal) %start
                    rvalue = own val %if (top_type = integer);  ! copy integer supplied into floater
                %finish
                pop stack
            %finish %else %start
                ! initialise to default pattern
                own val = 0
                current string(0) = 0;     ! in case it's a string
            %finish

            %if (own form = array) %or (own form = name array) %start
                adump %for j = 1,1,N
            %finish %else %if (otype = 0) %start
                ! %const .... %name
                ! JDM JDM attempt to allow assignment of %const ... %name
                decvar_scope = COT
                decvar_level = 0
                decvar_disp = own val
            %finish %else %start
                ! non-array normal variables
                decvar_level = 0
                %if (otype = con) %start
                    ! constant - must be string or real type, because
                    ! const integers are substituted by value in Pass 1
                    ! Constant strings and reals are treated as literals
                    decvar_scope = COT
                    %if (own type = string) %start
                        decvar_disp = getcots(current string)
                    %finish %else %if (own type = real) %or (own type = lreal) %start
                        ! constant reals are put in the COT.  Depending on how
                        ! the value was formed, ReadReal may have already planted this.
                        ! Not to worry, because "real constant" will find it again.
                        decvar_disp = getcotdouble(rvalue)
                    %finish %else %start
                        abort("Init?")
                    %finish
                %finish %else %start
                    ! must be %own or %external - use adump to put it in DATA segment
                    decvar_scope = DATA
                    decvar_disp = datatp
                    adump
                %finish
            %finish
        %end

        %routine User Jump( %integer label )

            ! JDM JDM debug show the iCode instruction
            %if (diagnose&16 # 0) %start
                ListICode
                spaces(4)
                printstring( get symbol name( label ) )
                newline
            %finish
            ! JDM JDM end debug

            dumpjump(JMP, user label( label ))
        %end

        %routine Define User Label( %integer label )

            ! JDM JDM debug show the iCode instruction
            %if (diagnose&16 # 0) %start
                ListICode
                spaces(4)
                printstring( get symbol name( label ) )
                newline
            %finish
            ! JDM JDM end debug

            dump label(user label( label ))
        %end

        %routine Return( %integer mode )
            ! JDM JDM replaces sequence of %if .. %then .. %else code
            ! to use %switch layout for clarity
            %switch sw(map:false)
            %label esac

            -> sw( mode) %if (map <= mode <= false)
            abort("Illegal mode for RETURN")

            sw(map):
                ! JDM JDM added for temporary debug
                %if (diagnose&4 # 0) %start
                    monitor(top, "RESULT MAP")
                %finish

                amap(top)
                loadreg(top, EAX)
                pop rel
                -> esac

            sw(fn):
                %begin
                    %switch st(integer:lreal)
                    %label esacst

                    ! JDM JDM added for temporary debug
                    %if (diagnose&4 # 0) %start
                        monitor(top, "RESULT FN")
                    %finish

                    ! Take action depending on the function returned type
                    -> st(procvar_type) %if (integer <= procvar_type <= lreal)
                    abort("Illegal function type (".itos(procvar_type,0).") for RETURN")

                    ! Functions returning one of %byte,%short,%integer,%long
                    ! should return that value in the %EAX register.
                    ! Functions returning one of %string,%record
                    ! should return that value in a hidden extra parameter
                    ! Functions returning one of %real,%longreal
                    ! should return that value as the only entry in the float stack
                    st(integer):
                    st(long):
                        ! 32-bit value is to be returned in the %EAX register
                        loadreg(top, EAX)

                        ! Now release the top of the stack
                        pop rel
                        -> esacst

                    st(short):
                        ! 16-bit value is to be returned in the %AX register (sub-set of %EAX)
                        loadreg(top, EAX)

                        ! Now release the top of the stack
                        pop rel
                        -> esacst

                    st(byte):
                        ! 8-bit value is to be returned in the %AL register (sub-set of %EAX)
                        loadreg(top, EAX)

                        ! Now release the top of the stack
                        pop rel
                        -> esacst

                    st(real):
                    st(lreal):
                        ! JDM JDM - For 32-bit code for IA-32 architecture ABI
                        ! JDM JDM - floating point results go onto the floating point stack in ST(0)
                        ! JDM JDM - that is the returned floating point stack should only be 1 deep
                        ! JDM JDM: loadreg(top,anyf) should push the result onto the floating point stack
                        loadreg(top, anyf);
                        pop rel
                        -> esacst

                    st(string):
                    st(record):
                        ! string - pass back through the hidden parameter
                        push copy(top);            ! Make a copy of the thing on top
                        lhs == stack(stp-1);       ! point to the (now spare) next item
                        lhs_type = procvar_type;   ! and make it look like a destination
                        lhs_size = procvar_size
                        lhs_format = procvar_format
                        lhs_base = EBP
                        lhs_disp = word size * 2;  ! At the offset of the last parameter
                        lhs_form = a in s
                        assign(1)
                        -> esacst

                    esacst:
                %end
                -> esac

            sw(routine):
                ! no need to do anything special
                -> esac

            sw(true):
                dumpri(MOV, EAX, -1)
                -> esac

            sw(false):
                dumpri(MOV, EAX, 0)
                -> esac

            esac:

            dump return
        %end

        %routine Dimension( %integer dim, n )
            %integer i,j, useCOT, descriptor

            ! JDM JDM debug show the iCode instruction
            %if (diagnose&16 # 0) %start
                ListICode
                spaces(4)
                printstring( itos(dim,0) )
                printsymbol( ',' )
                printstring( itos(n,0) )
                newline
            %finish
            ! JDM JDM end debug

            ! Validate the ICODE Parameters
            abort("Array Dim") %unless (0 < dim < 6)

            %if (in params # 0) %start
                ! This is an Array inside a Record
                ! NB. Only 1D arrays are allowed in a record!
                ! Defended against by the IMP grammar
                ! Hence the simplified code for a Dope Vector creation
                parms = parms + n
                vub = top_disp
                pop stack
                vlb = top_disp
                pop stack
                abort("Array Bounds") %if (vlb > vub)
                dv = set dope vector( data size, array entry type )
            %else
                names = names - n

                ! We should check to see if we can store the DopeVector in
                ! the COT table or on the machine stack
                ! Assume we have constant array bounds
                useCOT = 1
                ! Now iterate over the bounds
                j = 0
                ! points to before the first stack value
                %for i=1,1,dim*2 %cycle
                    j = j + 1
                    lhs == stack(j)
                    ! Determine if any bound is defined by a variable
                    %if (lhs_form # constant) %start
                        ! Drat! One of the bounds is NOT constant
                        ! So, we'll have to store the DV on the stack
                        useCOT = 0
                    %finish
                %repeat

                ! Now to plant code to manufacture space for a Dope Vector
                ! original DV definition
                !   :Dim:<bound pairs>:DataSize:
                ! new DV definition
                !   :Dim:<bound pairs>:DataSize<<5!DataType<<1!1:
                frame = (frame - 2*word size*(dim + 1) )&(\align)
                dv = frame

                ! First store the dimension (constant value)
                dumpmi(MOV, EBP, dv, 0, dim)

                ! Now the bounds (which may not be constant)
                j = 0
                ! points to before the first stack value
                %for i=1,1,dim*2 %cycle
                    j = j + 1
                    lhs == stack(j)
                    %if (lhs_form = constant) %start
                        dumpmi(MOV, EBP, dv + (i*word size), 0, lhs_disp)
                    %else
                        loadreg(lhs, any)
                        dumpmr(MOV, EBP, dv + (i*word size), 0, lhs_base)
                    %finish
                %repeat

                ! And the data size is also constant
                ! JDM JDM enhancement
                ! Make DV _size field to be a size/type/flag format descriptor
                descriptor = (data size<<5) ! ((array entry type&15)<<1) ! 1
                dumpmi(MOV, EBP, dv + (2*dim + 1) * word size, 0, descriptor )

                ! Now we need to allocate the space for the array
                ! Depending on the number of array dimensions
                %if (dim > 1) %or (control&check array # 0) %start
                    ! Do it with the PERM
                    %while (stp # 0) %cycle
                        ! get rid of all the bounds
                        !     they are in the DV already
                        pop rel
                    %repeat

                    dumprm(LEA, EAX, EBP, dv, 0)
                    dumpur(PUSH, EAX)
                    perm(adef, 1)

                    ! We now need to make our result match the in-line version
                    ! by putting EAX and EDX into stack-like variables
                    push const(0)
                    lhs == top

                    push const(0)
                    rhs == top

                    lhs_base = EAX
                    lhs_form = V in R
                    claim(EAX)

                    rhs_base = EDX
                    rhs_form = V in R
                    claim(EDX)

                    pop stack
                    pop stack
                %else
                    push const(1)
                    Operation(ADDx)
                    push const(data size)
                    Operation(MULx)
                    
                    ! suck up the lower bound
                    push copy(stack(stp-1))
                    push const(data size)
                    Operation(MULx)
                    ! top is now the lower bound,
                    ! next is the upper,
                    ! and a bogus copy of lb is next
                    loadreg(top, any);   ! Make sure this is in a register
                    lhs == top;          ! Point to it
                    pop stack;           ! and drop (without release) this copy
                    loadreg(top, any);   ! This is now UB - load it in a register as well
                    rhs == top;          ! Point to it
                    pop stack;           ! and keep RHS (Upper)
                    pop stack;           ! dump the bogus lb
                %finish

                ! Note - there are 4 GP registers, and we're going to need them ALL here
                t = gp reg;             ! get a working register for the dope vector address
                dumprm(LEA, t, EBP, dv, 0); ! load it
                dv = t
                claim(dv);               ! use this to hold the register number
                t = gp reg;              ! the last one! (which we don't claim, 'cos we can't lose it)
                dumprr(MOV, t, ESP);     ! working copy of SP so that real SP is always "OK"
            %finish

            %for i = 1,1,n %cycle
                decvar_dim = dim
                %if (in params = 0) %start
                    !  array not in record
                    names = names+1
                    decvar == var(names)
                    decvar_level = level
                    frame = frame - (word size * 2);  ! 2-word header
                    decvar_disp = frame

                    ! force arrayname?
                    %if (decvar_form = array) %or (decvar_form = namearray) %then decvar_form = decvar_form + 1

                    dumprr(SUB, t, rhs_base)
                    dumpmr(MOV, EBP, frame, 0, t);             ! store a(0) address
                    dumpmr(MOV, EBP, frame + word size, 0, dv);! store dope vector pointer
                    dumprr(ADD, t, lhs_base)
                %else
                    ! array-in-record
                    parms = parms-1
                    decvar == var(parms)
                    decvar_disp = frame - vlb

                    ! noting that Set Dope Vector has changed VUB to the array size
                    frame = frame + vub
                    decvar_pbase = dv
                %finish
            %repeat

            %if (in params = 0) %start
                ! We need to keep the stack pointer word aligned 
                ! - 8086's run faster that way,
                ! and more importantly,
                !     Pentiums throw an exception if you don't!
                %if (data size&align # 0) %then dumpri(AND, t, \align)
                dumprr(MOV,ESP,t)
                release(lhs_base)
                release(rhs_base)
                release(dv)
            %finish
        %end

        %routine Update Line( %integer line )

            ! JDM JDM debug show the iCode instruction
            %if (diagnose&16 # 0) %start
                ListICode
                spaces(4)
                printstring( itos( line,0) )
                newline
            %finish
            ! JDM JDM end debug

            current line = line
            abort("Stack?") %if (stp # 0)
            abort("Claimed") %if (claimed # 0)
            ! Pass1 sends the line number multiple times if there's more than
            ! one statement per line - for debugging we only want "real" line numbers
            %if (echo line < current line) %start
                dump line number(current line)
                %while (echo line < current line) %cycle
                    echo source line
                %repeat
            %finish
        %end

        %routine Switch Jump( %integer switch id )

            ! JDM JDM debug show the iCode instruction
            %if (diagnose&16 # 0) %start
                ListICode
                spaces(4)
                printsymbol( '"' )
                printstring( get symbol name( switch id) )
                printsymbol( '"' )
                newline
            %finish
            ! JDM JDM end debug

            v == var( switch id )
            push const(word size)
            Operation(MULx);        ! subscript X Word Size
            loadreg(top, anyp)
            dumpum(JMP, SWT!top_base, v_disp * word size, 0);       ! swtab is word-size
            pop rel
            uncond jump = next cad
        %end

        %routine Set Record Format( %integer format id )

            ! JDM JDM debug show the iCode instruction
            %if (diagnose&16 # 0) %start
                ListICode
                spaces(4)
                printsymbol( '=' )
                printsymbol( '"' )
                printstring( get symbol name( format id ) )
                printsymbol( '"' )
                newline
            %finish
            ! JDM JDM end debug

            top_format = format id
            top_type   = record
        %end

        %routine Switch Label( %integer switch label )

            ! JDM JDM debug show the iCode instruction
            %if (diagnose&16 # 0) %start
                ListICode
                spaces(4)
                printsymbol( '"' )
                printstring( get symbol name( switch label ) )
                printsymbol( '"' )
                newline
            %finish
            ! JDM JDM end debug

            v == var( switch label )
            uncond jump = 0
            j = top_disp
            pop stack
            
            t = new tag
            dumplabel(t);
            swtab(v_disp+j) = t;
        %end

        %routine Constant Bounds
            vub = top_disp
            pop stack

            vlb = top_disp
            pop stack
        %end

        %routine Internal Handler ( %integer id )
            %record(stackfm)%name  lh,rh
            %record(stackfm)  temp

            ! Check if event_sub, event_info values are present
            ! if not then load a default value=0
            push const(0) %while (stp < 2)

            ! So swop the stack entries ensuring the internal macro has valid parameters
            rh == top
            lh == stack(stp-1)
            temp = lh
            lh = rh
            rh = temp

            ! Now, stack the event_event value
            push const( id )
            ! JDM JDM extra feature - report the line invoking the %signal
            ! (extra parameter added to impsignal)
            push const( current line )

            ! load the parameters for impsignal( line, event, extra, sub )
            loadreg(top, any); dumpur(PUSH, top_base); pop rel; ! line
            loadreg(top, any); dumpur(PUSH, top_base); pop rel; ! event
            loadreg(top, any); dumpur(PUSH, top_base); pop rel; ! sub
            loadreg(top, any); dumpur(PUSH, top_base); pop rel; ! extra

            ! call imp signal, then pop the 4 parameters from the stack
            perm(signal, 4)
            uncond jump = next cad %if (id # -1);     ! %monitor will return
        %end

        %routine Signal Event( %integer event id )

            ! JDM JDM debug show the iCode instruction
            %if (diagnose&16 # 0) %start
                ListICode
                spaces(4)
                printstring( itos(event id,0) )
                newline
            %finish
            ! JDM JDM end debug

            Internal Handler ( event id )
        %end

        %routine Monitor
            Internal Handler ( -1 )
        %end

        %routine SelectField( %integer field index )

            ! JDM JDM debug show the iCode instruction
            %if (diagnose&16 # 0) %start
                ListICode
                spaces(4)
                printstring( itos(field index,0) )
                newline
            %finish
            ! JDM JDM end debug

            ! Contrary to earlier iCode versions, this one seems to use 'n' for
            ! both normal record member access and alternate formats?

            ! Points to the base record
            lhs == top

            ! Push descriptor for the i-th member
            Stack Var(var(top_format)_pbase - field index)

            %if (top_aform # recordformat) %start
                !  not record format - must be a member
                %if (lhs_form = V in S) %or (lhs_form = V in REC) %start
                    top_disp = top_disp + lhs_disp
                    lhs_form = lhs_form - V in S + top_form
                %else
                    %if (lhs_form = A in REC) %start
                        lhs_form = V in REC
                        lhs_type = integer
                        loadreg(lhs,any)
                        lhs_form = top_form
                    %else
                        %if (lhs_form <= V in R) %start
                            lhs_form = top_form;    ! ????
                        %else
                            ! A in S
                            lhs_extra = lhs_disp
                            lhs_form = top_form + 3
                        %finish
                    %finish
                %finish
                lhs_disp = top_disp
                lhs_type = top_type
                lhs_aform = top_aform
                lhs_dim = top_dim
            %finish
            lhs_size = top_size
            lhs_format = top_format
            pop stack
        %end

        %routine EventTrap( %integer anevent, evfrom )
            ! events: Events to trap (then comma)
            ! evfrom: Label to skip to
            %integer temp

            ! JDM JDM debug show the iCode instruction
            %if (diagnose&16 # 0) %start
                ListICode
                spaces(4)
                printstring( itos(anevent,0) )
                printsymbol( ',' )
                printstring( itos(evfrom,0) )
                newline
            %finish
            ! JDM JDM end debug

            events = anevent
            temp = getwork(word size);      ! get a temp location for SP
            dumpmr(MOV, EBP, temp, 0, ESP); ! because our signaller doesn't restore it
            jump to(evfrom, JMP, 1);        ! go there now
            ! We need to make EVFROM into a label ID that pass 3 will recognise
            ! to build the trap table, so Jump To sets a variable we pick up here...
            evfrom = J Tag
            evep = new tag;                 ! tag for the event body entry point
            dump label(evep);               ! which is here
            dumprm(MOV, ESP, EBP, temp, 0); ! First thing we do is restore SP
        %end

        %routine DoubleOp( %integer opr )
            %integer j,t

            lhs == stack(stp-1)
            t = lhs_type
            j = lhs_size
            j = j+1 %if t = string
            amap(lhs)
            abort("++/-- size") %if (j = 0)
            push const(j)
            Operation(MULx)
            Operation(opr)
            vmap(top)
            top_type = t
        %end

        %routine Set Diagnose(%integer Value)

            ! JDM JDM set value for the appropriate compiler pass
            ! In this case we are in pass2
            diagnose = (Value&x'3FFF') %if (Value&x'C000' = (PassId&3)<<14)

            ! use the updated diagnose value
            ! JDM JDM debug show the iCode instruction
            %if (diagnose&16 # 0) %start
                ListICode
                spaces(4)
                printstring( itos(value,0) )
                newline
            %finish
            ! JDM JDM end debug

        %end

        %routine Set Control(%integer Value)

            ! JDM JDM debug show the iCode instruction
            %if (diagnose&16 # 0) %start
                ListICode
                spaces(4)
                printstring( itos(value,0) )
                newline
            %finish
            ! JDM JDM end debug

            ! JDM JDM set value for the appropriate compiler pass
            ! In this case we are in pass2
            control = Value&x'3FFF' %if (Value&x'C000' = (PassId&3)<<14)
        %end

        %predicate Finish Params
            %integer j

            in params = 0

            %true %if (amode < 0);            ! end of %record %format defn.
            %true %if (procvar_level = 128);  ! prim routine reference

            ! Here it's a real subroutine - copy any parameters to the PARM area
            %if (names > first name) %start
                procvar_pbase = parms;  ! Point one beyond the first parameter
                frame = (frame + align) & (\align); ! Even up the stack size
                %if (procvar_type = string) %and (procvar_form = 8) %start
                    frame = frame + word size;  ! string functions have a hidden result parameter
                %finish
                procvar_extra = frame;             ! Remember the stack offset
                procvar_dim = names - first name;  ! and the number of parameters
                frame = frame + (2 * word size);   ! leave space for return linkage (EIP + EBP)
                %for j = first name+1, 1, names %cycle
                    ap == var(j)
                    parms = parms-1
                    fp == var(parms)
                    fp = ap
                    ! formal parameter base and displacement is implicit (on the stack)
                    fp_level = 0
                    ! we also need to adjust the offsets of the actual parameters, because
                    ! they were allocated going "forwards", but will be pushed on the stack
                    ! "backwards" - that is, the first item passed will end up with the
                    ! highest address.  DefineVar has done part of the work for us by tagging
                    ! the displacements in the right style, but it can't tell the whole frame
                    ! offset, so we calculate the final offsets here...
                    ap_disp = frame - ap_disp
                %repeat
                abort("Params (names=".itos(names,0)." parms=".itos(parms,0).")") %if parms < names
            %finish

            %true %if (amode = 2);  ! this was just a spec

            dumplabel(procvar_disp)
            static alloc = enter
            frame = -(level * word size);  ! one word for each display entry
            %false
        %end

        %routine Start Params

            in params = -1
            ! this is either
            ! a record format,
            ! a procedure,
            ! or a proc spec;
            !   - block type was set by decvar to tell us which
            assemble(block type,labs,names);
        %end

        ! alt start
        %routine AlternateStart
            decvar == procvar
            assemble(-2,labs,names)
        %end

        ! alt next
        %routine AlternateNext
            ! Compile the next alternate - update limit and set frame back to where we started
            max frame = frame %if (frame > max frame)
            frame = old frame
        %end

        %predicate AlternateFormat( %integer N )

            ! JDM JDM debug show the iCode instruction
            %if (diagnose&16 # 0) %start
                ListICode
                spaces(4)
                printsymbol( N )
                newline
            %finish
            ! JDM JDM end debug

            ! Check the ICODE for faults
            ! and abort for any faulty intermediate code
            abort("Alt Record '".tostring(N)."'.") %unless (N = 'A') %or (N = 'B') %or (N = 'C')

            %true %if (N = 'B');             ! alt end

            %if (N = 'A') %start
                ! alt start
                decvar == procvar
                assemble(-2,labs,names)
            %finish

            %if (N = 'C') %start
                ! Compile the next alternate - update limit and set frame back to where we started
                max frame = frame %if (frame > max frame)
                frame = old frame
            %finish
            %false
        %end

        %routine  Plant
            ! Plant in-line code values (from "*=constant")

            ! We only expect one item on the stack
            abort("Machine Literal") %if (stp <> 1)

            lhs == stack(1)
            putbyte(lhs_disp&255)

            listpreamble
            printstring("*=16_")
            writehex(lhs_disp&255, 2)
            newline

            writeifrecord(IF OBJ)

            ! JDM JDM empty the icode stack
            pop stack
        %end

        %include "machinecode.inc"

        !--------------------------------------------------------------
        ! Code for ASSEMBLE starts here...
        First Name = Names
        First Label = Labs
        Proc Var == Decvar
        last skip = -1
        old frame = frame
        frame = 0
        events = 0
        evep = 0
        evfrom = 0

        %if (amode >= 0) %start
            ! Not a RecordFormat
            level = level+1
            abort("Level") %if (level > max level) %and (spec = 0)
            worklist(level) = 0

            %if (amode = 0) %start;
                ! %begin block
                %if (level = 1) %start
                    ! Initial %begin ?
                    ! Name the block for stack traceback readability
                    block name = program ip

                    ! remember the program entry name for the linker
                    external id = program ep
                    otype = external
                    potype = otype
                %else
                    block name = "%begin block"
                %finish
                static alloc = enter
                frame = -(level * word size);  ! 1 word for each display entry
            %finish
        %else
            %if (amode = -1) %start
                ! normal record format
                ProcVar_pbase = parms;        ! where our members start
            %else
                ! alternates start at the current offset
                %if (amode = -2) %then frame = oldframe
            %finish
            ! start counting space here
            max frame = frame
        %finish

        !  --- main compilation loop ---
        %cycle
            iCodeInst = read iCode

            ! count how many iCode instructions have been read
            iCodeCount = iCodeCount + 1

            ! defend against illegal iCode instructions
            %if (getiCodeName(iCodeInst)="ILLEGAL") %start
                selectoutput(0)
                printsymbol('(')
                write(iCodeInst, 0)
                printsymbol(',')
                write(lookahead icode, 0)
                printsymbol(')')
                abort("Bad I Code")
            %finish
            ! From this point the iCodeInst is a legal iCode
            ! Hopefully the iCode instruction parameters are valid

            -> c(iCodeInst)

c(iCodeOR):
            %if (diagnose&16 # 0) %then ListICodeLine
            Operation( ORx )
            %continue

c(iCodeCOMPARED):
            %if (diagnose&16 # 0) %then ListICodeLine
            Compare Double
            %continue

c(iCodeJNE):
            Jump Forward( ReadTag, NE )
            %continue

c(iCodeDEF):
            Define Var( ReadTag, Get Ascii( ',' ), ReadTagComma, ReadTagComma, ReadTag )
            %continue

c(iCodeXOR):
            %if (diagnose&16 # 0) %then ListICodeLine
            Operation( XORx )
            %continue

c(iCodeAND):
            %if (diagnose&16 # 0) %then ListICodeLine
            Operation( ANDx )
            %continue

c(iCodePUSHS):
            ! Stack string constant
            Input String Value( ReadString )
            %continue

c(iCodeJLE):
            Jump Forward( ReadTag, LE )
            %continue

c(iCodeJGE):
            Jump Forward( ReadTag, GE )
            %continue

c(iCodeMUL):
            %if (diagnose&16 # 0) %then ListICodeLine
            Operation( MULx )
            %continue

c(iCodeADD):
            %if (diagnose&16 # 0) %then ListICodeLine
            Operation( ADDx )
            %continue

c(iCodeSUB):
            %if (diagnose&16 # 0) %then ListICodeLine
            Operation( SUBx )
            %continue

c(iCodeCONCAT):
            %if (diagnose&16 # 0) %then ListICodeLine
            Operation( CONCx )
            %continue

c(iCodeQUOT):
            %if (diagnose&16 # 0) %then ListICodeLine
            Operation( DIVx )
            %continue

c(iCodeLOCATE):
            ! Define compiler label
            Define Compiler Label( ReadTag )
            %continue

c(iCodeEND):
            %if (diagnose&16 # 0) %then ListICodeLine
            End of Block
            %exit

c(iCodeJL):
            Jump Forward( ReadTag, LT )
            %continue

c(iCodeJE):
            Jump Forward( ReadTag, EQ )
            %continue

c(iCodeJG):
            Jump Forward( ReadTag, GT )
            %continue

c(iCodeCOMPARE):
            ! Compare values
            %if (diagnose&16 # 0) %then ListICodeLine
            Compare Values
            %continue

c(iCodePUSH):
            ! Load variable descriptor (calls Stack Var)
            Load Var( ReadTag )
            %continue

c(iCodeINIT):
            ! Initialise OWN variable
            Init( ReadTag )
            %continue

c(iCodeREPEAT):
            ! Backward Jump
            Jump Backward( ReadTag )
            %continue

c(iCodeCOMPAREA):
            ! Compare addresses
            %if (diagnose&16 # 0) %then ListICodeLine
            Compare Addresses
            %continue

c(iCodePUSHR):
            ! Stack real constant
            Input Real Value( ReadReal )
            %continue

c(iCodeCALL):
            %if (diagnose&16 # 0) %then ListICodeLine
            Compile Call( top )
            %continue

c(iCodeGOTO):
            ! Forward Jump
            Jump Forward( ReadTag, Always )
            %continue

c(iCodeALIAS):
            ! Alias for item about to be declared
            Alias = ReadString
            %if (diagnose&16 # 0) %start
                ListICode
                spaces(4)
                printsymbol( '"' )
                printstring( Alias )
                printsymbol( '"' )
                newline
            %finish
            %continue

c(iCodeBEGIN):
            ! Start of BEGIN block
            %if (diagnose&16 # 0) %then ListICodeLine
            Compile Begin
            %continue

c(iCodeJUMP):
            ! Jump to user label
            User Jump( ReadTag )
            %continue

c(iCodeFALSE):
            ! %false
            %if (diagnose&16 # 0) %then ListICodeLine
            Return( False )
            %continue

c(iCodeLABEL):
            ! Define user label
            Define User Label( ReadTag )
            %continue

c(iCodeMAP):
            ! MAP result
            %if (diagnose&16 # 0) %then ListICodeLine
            Return( Map )
            %continue

c(iCodePUSHI):
            ! Load integer constant (calls Push Const)
            Load Const( ReadInteger )
            %continue

c(iCodeLINE):
            ! Set line number
            Update Line( ReadTag )
            %continue

c(iCodePLANT):
            ! Machine code literal
            %if (diagnose&16 # 0) %then ListICodeLine
            Plant
            %continue

c(iCodeDIVIDE):
            %if (diagnose&16 # 0) %then ListICodeLine
            Operation( RDIVx )
            %continue

c(iCodeRETURN):
            ! RETURN
            %if (diagnose&16 # 0) %then ListICodeLine
            Return( Routine )
            %continue

c(iCodeASSVAL):
            ! Normal value assignment
            %if (diagnose&16 # 0) %then ListICodeLine
            Assign( 1 )
            %continue

c(iCodeTRUE):
            ! %true
            %if (diagnose&16 # 0) %then ListICodeLine
            Return( True )
            %continue

c(iCodeNEGATE):
            %if (diagnose&16 # 0) %then ListICodeLine
            Operation( NEGx )
            %continue

c(iCodeRESULT):
            ! FN result
            %if (diagnose&16 # 0) %then ListICodeLine
            Return( Fn )
            %continue

c(iCodeSJUMP):
            ! Jump to switch
            Switch Jump( ReadTag )
            %continue

c(iCodeIEXP):
            %if (diagnose&16 # 0) %then ListICodeLine
            Operation( EXPx )
            %continue

c(iCodeASSREF):
            ! Assign address '=='
            %if (diagnose&16 # 0) %then ListICodeLine
            Assign( 0 )
            %continue

c(iCodeLSH):
            %if (diagnose&16 # 0) %then ListICodeLine
            Operation( LSHx )
            %continue

c(iCodeNOT):
            %if (diagnose&16 # 0) %then ListICodeLine
            Operation( NOTx )
            %continue

c(iCodeRSH):
            %if (diagnose&16 # 0) %then ListICodeLine
            Operation( RSHx )
            %continue

c(iCodeSETFORMAT):
            ! {Set Format}
            Set Record Format( ReadTag )
            %continue

c(iCodeSLABEL):
            ! Define switch label
            Switch Label( ReadTag )
            %continue

c(iCodeACCESS):
            %if (diagnose&16 # 0) %then ListICodeLine
            Array Ref( 0 )
            %continue

c(iCodeBOUNDS):
            ! Define constant bounded Dope Vector
            %if (diagnose&16 # 0) %then ListICodeLine
            Constant Bounds
            %continue

c(iCodeALTNEXT):
            %if (diagnose&16 # 0) %then ListICode
            AlternateNext
            %continue

c(iCodeDIM):
            ! dimensions, count of variables
            ! NB in params:  =0 -> simple array,  # 0 -> array-in-record
            Dimension( ReadTagComma, ReadTag )
            %continue

c(iCodeEVENT):
            ! %signal event
            Signal Event( ReadTag )
            %continue

c(iCodeFOR):
            Compile For( ReadTag )
            %continue

c(iCodeALTSTART):
            %if (diagnose&16 # 0) %then ListICodeLine
            AlternateStart
            %continue

c(iCodeALTEND):
            %if (diagnose&16 # 0) %then ListICodeLine
            ! do nothing but pop out of the loop
            %exit

c(iCodeINDEX):
            %if (diagnose&16 # 0) %then ListICodeLine
            Array Ref( 1 )
            %continue

c(iCodeJAM):
            ! JAM transfer
            %if (diagnose&16 # 0) %then ListICodeLine
            Assign( 2 )
            %continue

c(iCodeJZ):
            ! Branch on FALSE (= 0)
            Jump Forward( ReadTag, FF )
            %continue

c(iCodeLANG):
            ! We currently only support standard IMP - who knows the future
            Language Flags = ReadTag

            %if (diagnose&16 # 0) %start
                ListICode
                spaces(4)
                printstring( itos( Language Flags, 0 ) )
                newline
            %finish
            %continue

c(iCodeMONITOR):
            ! %monitor
            %if (diagnose&16 # 0) %then ListICodeLine
            Monitor
            %continue

c(iCodeSELECT):
            ! Select member from record format
            SelectField( ReadTag )
            %continue

c(iCodeON):
            ! %on %event block
            EventTrap( ReadTagComma, ReadTag )
            %continue

c(iCodeASSPAR):
            ! Pass a parameter
            %if (diagnose&16 # 0) %then ListICodeLine
            Assign( -1 )
            %continue

c(iCodeSUBA):
            ! --
            %if (diagnose&16 # 0) %then ListICodeLine
            DoubleOp( SUBx )
            %continue

c(iCodeRESOLVE):
            Resolve( ReadTag )
            %continue

c(iCodeSTOP):
            ! %stop
            %if (diagnose&16 # 0) %then ListICodeLine
            perm( stop, 0 )
            %continue

c(iCodeJNZ):
            ! Branch on TRUE (# 0)
            Jump Forward( ReadTag, TT )
            %continue

c(iCodeADDA):
            ! ++
            %if (diagnose&16 # 0) %then ListICodeLine
            DoubleOp( ADDx )
            %continue

c(iCodeMOD):
            %if (diagnose&16 # 0) %then ListICodeLine
            Operation( ABSx )
            %continue

c(iCodeMCODE):
            ! JDM JDM: escape to machine assembler code
            Machine Code( Get Ascii( ';' ) )
            %continue

c(iCodeREXP):
            %if (diagnose&16 # 0) %then ListICodeLine
            Operation( REXPx )
            %continue

c(iCodeDIAG):
            ! %diagnose n (what about pass3? how do we send to pass3)
            Set Diagnose( ReadTag )
            %continue

c(iCodeCONTROL):
            ! %control n
            Set Control( ReadTag )
            %continue

c(iCodeSTART):
            ! Start of formal parameters
            %if (diagnose&16 # 0) %then ListICodeLine
            Start Params
            %continue

c(iCodeFINISH):
            ! End of formal parameters
            %if (diagnose&16 # 0) %then ListICodeLine
            %exit %if Finish Params
            %continue

c(iCodeALT):
            ! alternate record format
            %exit %if AlternateFormat( ReadByte )
            %continue

c( * ):
            ! To catch the sinners!! (that is - an unimplemented iCode)
            abort("Bad I Code")
        %repeat
 
        %if (amode >= 0) %start
            ! end of declarative block
            %while (worklist(level) # 0) %cycle
                worklist(level) = ret gp tag(worklist(level))
            %repeat
            level = level-1
        %else
            ! end of record format defn
            %if (amode = -2) %start
                ! end of alternative only
                ! use the longest alternative
                frame = max frame %if (max frame > frame)
                old frame = frame
            %else
                ! **** temporary ****
                frame = (frame+align)&(\align)
                procvar_size = frame
            %finish
        %finish
        frame = old frame

    %end;  ! assemble

    %routine initialise pass2
        %string(255) the source file name
        %integer i,j

        ! The %signal 9,0 and %signal 9,1 events are allowed by default
        ! However, these events should not be triggered inside  pass2
        ! when reading the .icd or .imp source files
        block eof event

        ! Is there a shell variable (IMP_DIAGNOSE=NNN) override for diagnose?
        diagnose = get env as integer( "IMP_DIAGNOSE" )

        ! JDM JDM - Before we do any file I/O we need to get the source file name
        ! (as used to feed the 'source' stream)

        select input( source )
        the source file name = input name

        ! JDM JDM - ok, now we can really start
        select input( icode )
        select output( objout )
        ! Tell the IBJ buffer routines the objout stream#
        setibjoutstream( objout )

        var(0) = 0;              !  for %RECORD( * ) . . . . .
        parms = max vars

        ! Initialise the GP Tag ASL
        %for i=1,1,Max GP %cycle
            GP Tags(i)_link = i - 1
        %repeat
        gp asl = Max GP

        ! Tell the linker our source file name
        dumpsourcename( the source file name )

        ! predefine the perms for the linker
        ! We ignore the number (j) because we know they are in sequence
        %for i=1,1,lastperm %cycle
            j = externalref(permname(i))
        %repeat
        ! Add some "hidden" routines
        check1 = externalref(hidden name(1))
        check2 = externalref(hidden name(2))
        check3 = externalref(hidden name(3))
        lasthidden = lastperm + 3
    %end

    !              -------- it all starts here ---------
    initialise pass2

    !  Prime SYM/NEXT pair
    next icode

    Spec = 0
    decvar == begin
    assemble(-3,0,0)

    ! We flush constants
    flush cot
    flush data
    flush switch

    %if (diagnose&4 # 0) %start
        debugnewline
        debugstring(" Maximum depth of symbol stack = ".itos(get max tag,0))
        debugnewline
    %finish

%endofprogram
